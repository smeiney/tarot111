<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="tarot-build" content="2026-01-31-01">
    <title>Mystic Tarot | Á•ûÁßòÂ°îÁΩó</title>
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <!-- Markdown Renderer -->
    <script src="https://cdn.jsdelivr.net/npm/marked/lib/marked.umd.js" crossorigin="anonymous"></script>
    
    <style>
        :root {
            --card-width: clamp(120px, 20vw, 200px);
            --card-height: calc(var(--card-width) * 1.75);
            --bg-dark: #050510;
            --accent-gold: #d4af37;
            --accent-glow: rgba(212, 175, 55, 0.6);
        }

        @media (max-width: 768px) and (orientation: portrait) {
            :root {
                --card-width: clamp(92px, 24vw, 150px);
            }
        }

        @media (max-width: 480px) and (orientation: portrait) {
            :root {
                --card-width: clamp(86px, 26vw, 140px);
            }
        }

        @media (orientation: landscape) and (max-height: 520px) {
            :root {
                --card-width: clamp(96px, 26vh, 140px);
            }
        }

        /* Intro Animation Class - if needed, but we will use JS interpolation */
        
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-dark);
            font-family: 'Cinzel', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #eee;
            user-select: none;
        }

        /* Background Effects */
        #stars-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.8;
        }

        #fog-layer {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40%;
            background: linear-gradient(to top, rgba(10,10,30, 0.9), transparent);
            z-index: 1;
            pointer-events: none;
        }

        #asset-loader {
            position: fixed;
            inset: 0;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            background: rgba(5, 5, 16, 0.92);
            backdrop-filter: blur(6px);
            pointer-events: auto;
        }

        #asset-progress-container {
            width: min(320px, 80vw);
            height: 8px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 999px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.08);
        }

        #asset-progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, rgba(212, 175, 55, 0.7), rgba(240, 230, 140, 0.9));
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.35);
            transition: width 0.15s linear;
        }

        /* Main Game Container */
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            perspective: 1200px; /* Increased perspective for deeper look */
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* 3D Scene for Cards */
        #scene {
            width: 100%;
            height: 60vh;
            position: relative;
            transform-style: preserve-3d;
            /* removed transition, we handle it in JS loop */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Card Styles */
        .card-wrapper {
            position: absolute;
            width: var(--card-width);
            height: var(--card-height);
            transform-style: preserve-3d;
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), box-shadow 0.3s;
            cursor: pointer;
            border-radius: 15px;
        }

        .card-wrapper.selected {
            box-shadow: 0 0 30px var(--accent-glow);
            z-index: 100;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.8s;
            transform-style: preserve-3d;
            border-radius: 15px;
        }

        .card-wrapper.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            overflow: hidden;
            border: 2px solid #333;
        }

        .card-back {
            background: repeating-linear-gradient(
                45deg,
                #1a1a2e,
                #1a1a2e 10px,
                #16213e 10px,
                #16213e 20px
            );
            background-image: url('https://www.transparenttextures.com/patterns/black-thread.png'); /* Fallback or simple pattern */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Elaborate back design using CSS pseudo-elements */
        .card-back::after {
            content: '‚ú¶';
            font-size: 3rem;
            color: rgba(212, 175, 55, 0.3);
            border: 2px solid rgba(212, 175, 55, 0.3);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-front {
            background-color: #fff;
            transform: rotateY(180deg);
            background-size: cover;
            background-position: center;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        #header {
            text-align: center;
            text-shadow: 0 0 10px var(--accent-gold);
            margin-top: 20px;
        }
        
        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 5px;
            color: var(--accent-gold);
        }

        #status-text {
            text-align: center;
            font-size: 1.2rem;
            color: #aaa;
            margin-top: 10px;
            text-shadow: 0 0 5px black;
        }

        #controls {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .btn {
            background: transparent;
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
            padding: 10px 30px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: rgba(0,0,0,0.5);
            border-radius: 30px;
        }

        .btn:hover {
            background: var(--accent-gold);
            color: #000;
            box-shadow: 0 0 20px var(--accent-glow);
        }

        #webcam-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border: 1px solid var(--accent-gold);
            opacity: 0.5;
            border-radius: 10px;
            transform: scaleX(-1); /* Mirror */
            z-index: 100;
        }

        #question-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 700px;
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid var(--accent-gold);
            padding: 40px;
            border-radius: 20px;
            color: #eee;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 60px rgba(212, 175, 55, 0.3);
            z-index: 1000;
            text-align: center;
            will-change: auto;
        }

        #question-modal h2 {
            color: var(--accent-gold);
            margin-top: 0;
            font-size: 1.8rem;
            letter-spacing: 3px;
        }

        #question-modal .question-subtitle {
            color: #aaa;
            font-size: 1rem;
            margin-bottom: 30px;
            font-style: italic;
        }

        #question-modal textarea {
            width: 100%;
            height: 120px;
            padding: 15px;
            border: 1px solid var(--accent-gold);
            background: rgba(0, 0, 0, 0.5);
            color: #eee;
            border-radius: 10px;
            font-family: inherit;
            font-size: 1rem;
            resize: none;
            box-sizing: border-box;
            margin-bottom: 20px;
        }

        #question-modal textarea:focus {
            outline: none;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            border-color: #f0e68c;
        }

        #question-modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        #question-modal-buttons .btn {
            flex: 1;
            max-width: 200px;
        }

        #music-recommendation-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 900px;
            max-height: 85vh;
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid var(--accent-gold);
            padding: 40px;
            border-radius: 20px;
            color: #eee;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 60px rgba(212, 175, 55, 0.4);
            z-index: 1100;
            overflow-y: auto;
            will-change: auto;
        }

        #music-recommendation-modal h2 {
            color: var(--accent-gold);
            text-align: center;
            margin-top: 0;
            font-size: 1.8rem;
            letter-spacing: 3px;
        }

        #music-recommendation-modal .music-intro {
            text-align: center;
            color: #aaa;
            font-size: 1rem;
            margin-bottom: 30px;
            font-style: italic;
        }

        #music-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .music-item {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(212, 175, 55, 0.3);
            padding: 15px;
            border-radius: 10px;
            transition: all 0.3s;
        }

        .music-item:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
            background: rgba(0, 0, 0, 0.7);
        }

        .music-item-title {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .music-item-artist {
            color: #bbb;
            font-size: 0.95rem;
            margin-bottom: 10px;
        }

        .music-item-reason {
            color: #999;
            font-size: 0.85rem;
            line-height: 1.5;
            margin-bottom: 10px;
            font-style: italic;
        }

        .music-item-btn {
            display: inline-block;
            padding: 6px 12px;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s;
        }

        .music-item-btn:hover {
            background: var(--accent-gold);
            color: #000;
        }

        #music-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        #music-actions .btn {
            flex: 0 1 auto;
        }
        
        /* ÂµåÂÖ•ÂºèÈü≥‰πêÊí≠ÊîæÂô®Ê†∑Âºè */
        #embedded-music-player {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid var(--accent-gold);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
            z-index: 2000;
            backdrop-filter: blur(10px);
        }
        
        #embedded-music-player .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 0.95rem;
        }
        
        #embedded-music-player audio {
            width: 100%;
            margin: 10px 0;
        }
        
        #embedded-music-player .player-info {
            color: #bbb;
            font-size: 0.85rem;
            margin-top: 5px;
            font-style: italic;
        }

        #location-recommendation-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 1000px;
            max-height: 85vh;
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid var(--accent-gold);
            padding: 40px;
            border-radius: 20px;
            color: #eee;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 60px rgba(212, 175, 55, 0.4);
            z-index: 1200;
            overflow-y: auto;
            will-change: auto;
        }

        #location-recommendation-modal h2 {
            color: var(--accent-gold);
            text-align: center;
            margin-top: 0;
            font-size: 1.8rem;
            letter-spacing: 3px;
        }

        #location-recommendation-modal .location-intro {
            text-align: center;
            color: #aaa;
            font-size: 1rem;
            margin-bottom: 20px;
            font-style: italic;
        }

        #location-map-container {
            width: 100%;
            height: 400px;
            border-radius: 10px;
            border: 1px solid rgba(212, 175, 55, 0.3);
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        #location-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .location-item {
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(212, 175, 55, 0.3);
            padding: 15px;
            border-radius: 10px;
            transition: all 0.3s;
        }

        .location-item:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
            background: rgba(0, 0, 0, 0.7);
        }

        .location-item-name {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }

        .location-item-category {
            display: inline-block;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            margin-bottom: 8px;
        }

        .location-item-distance {
            color: #bbb;
            font-size: 0.95rem;
            margin-bottom: 5px;
        }

        .location-item-reason {
            color: #999;
            font-size: 0.85rem;
            line-height: 1.5;
            margin-bottom: 10px;
            font-style: italic;
        }

        .location-item-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .location-item-btn {
            display: inline-block;
            padding: 6px 10px;
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s;
        }

        .location-item-btn:hover {
            background: var(--accent-gold);
            color: #000;
        }

        #location-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        #location-actions .btn {
            flex: 0 1 auto;
        }

        #interpretation-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid var(--accent-gold);
            padding: 30px;
            border-radius: 20px;
            color: #eee;
            overflow-y: auto;
            display: none;
            pointer-events: auto;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        
        #interpretation-modal.show {
            opacity: 1;
        }

        #interpretation-content {
            line-height: 1.8;
            font-size: 1.1rem;
            min-height: 100px;
            opacity: 1;
        }
        
        #interpretation-content h3 {
            color: var(--accent-gold);
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        #token-input-container {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
            z-index: 100;
        }
        
        #api-token {
            background: rgba(0,0,0,0.5);
            border: 1px solid #555;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            width: 150px;
            transition: width 0.3s;
        }
        
        #api-token:focus {
            width: 300px;
            border-color: var(--accent-gold);
            outline: none;
        }

        /* Hand Gesture Guide */
            #gesture-guide {
                position: absolute;
                bottom: 150px;
                left: 50%;
                transform: translateX(-50%);
                display: none; /* Removed based on user request */
                gap: 20px;
                opacity: 0;
                transition: opacity 0.5s;
                pointer-events: none;
                width: 100%;
                justify-content: center;
            }
        
        .guide-zone {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 30%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: rgba(212, 175, 55, 0.5);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none; /* Ensure no blocking */
        }
        
        #zone-left { left: 0; justify-content: flex-start; padding-left: 50px; }
        #zone-right { right: 0; justify-content: flex-end; padding-right: 50px; }
        #zone-center { 
            left: 30%; 
            width: 40%; 
            align-items: flex-end;
            padding-bottom: 180px;
        }

        .guide-zone.active {
            opacity: 1;
            text-shadow: 0 0 20px var(--accent-gold);
        }
        
        /* New Pulse Animation */
        @keyframes pulseRing {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; border-width: 5px; }
            100% { transform: translate(-50%, -50%) scale(2.0); opacity: 0; border-width: 0px; }
        }
        
        .guide-icon {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            border: 1px solid transparent;
        }
        
        .guide-icon.active {
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.2);
            box-shadow: 0 0 15px var(--accent-glow);
            transform: scale(1.2);
        }

        /* Cursor & Particles */
        #hand-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid var(--accent-gold);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px var(--accent-glow);
            transition: width 0.2s, height 0.2s, background-color 0.2s;
            display: none; /* Hidden until hand detected */
        }
        
        /* Removed grabbing state as requested */
        /* #hand-cursor.grabbing { ... } */

        .cursor-trail {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--accent-glow);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            opacity: 0.8;
            animation: fadeTrail 0.5s forwards;
        }

        @keyframes fadeTrail {
            to { opacity: 0; transform: scale(0.2); }
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ffffff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 2001;
            animation: riseAndFade 0.8s ease-out forwards;
            box-shadow: 0 0 10px #ffffff, 0 0 20px #ffffff;
        }

        @keyframes riseAndFade {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -150px) scale(0.2); opacity: 0; }
        }

        /* Charge Progress Bar */
        #charge-progress-container {
            width: 200px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin: 10px auto;
            overflow: hidden;
            display: none; /* Hidden by default */
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(255,255,255,0.1);
        }
        
        #charge-progress-bar {
            width: 0%;
            height: 100%;
            background: #fff;
            box-shadow: 0 0 10px #fff;
            transition: width 0.1s linear;
        }

        /* Charge Ring */
        #charge-ring {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 4px solid var(--accent-gold);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1001;
            transform: translate(-50%, -50%) scale(0);
            opacity: 0;
            transition: transform 0.1s linear;
        }

        /* Picked Card Zone */
        #picked-zone {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: none; /* Hidden initially */
            gap: 20px;
            z-index: 50;
            pointer-events: none;
        }

        .picked-slot {
            width: calc(var(--card-width) * 0.5);
            height: calc(var(--card-height) * 0.5);
            border: 2px dashed rgba(212, 175, 55, 0.3);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.3);
            transition: all 0.5s;
        }

        @media (max-width: 480px) {
            #picked-zone {
                bottom: 20px;
                gap: 12px;
            }
        }

        .picked-slot.filled {
            border-style: solid;
            border-color: var(--accent-gold);
            background: rgba(0,0,0,0.6);
        }

        .mini-card {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background-size: cover;
            background-position: center;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            animation: flyIn 0.5s ease-out;
        }

        @keyframes flyIn {
            from { transform: translateY(-300px) scale(1.5); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        /* Loading Spinner */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--accent-gold);
            animation: spin 1s linear infinite;
            display: none;
            margin: 20px auto;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Settings Icon */
        #settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            color: var(--accent-gold);
            cursor: pointer;
            z-index: 1000;
            transition: transform 0.5s;
            pointer-events: auto; /* Enable clicks */
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            border: 1px solid transparent;
        }
        #settings-btn:hover {
            transform: rotate(90deg);
            border-color: var(--accent-gold);
            background: rgba(212, 175, 55, 0.1);
        }

        /* Settings Modal */
        #settings-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 3000;
            backdrop-filter: blur(5px);
        }
        .settings-content {
            background: #111;
            border: 2px solid var(--accent-gold);
            width: 90%;
            max-width: 400px;
            margin: 15vh auto;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            color: #eee;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .settings-content input {
            width: 80%;
            padding: 10px;
            margin: 20px 0;
            background: #222;
            border: 1px solid #444;
            color: white;
            border-radius: 5px;
            font-size: 1rem;
        }
        .settings-content a {
            color: var(--accent-gold);
            text-decoration: underline;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #111;
        }
        ::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Music Player Styles */
        #music-player {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 150;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #music-toggle-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(212, 175, 55, 0.8);
            border: 2px solid var(--accent-gold);
            color: #000;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #music-toggle-btn:hover {
            background: var(--accent-gold);
            box-shadow: 0 0 15px var(--accent-glow);
            transform: scale(1.1);
        }

        #music-player-panel {
            background: rgba(10, 10, 20, 0.95);
            border: 1px solid var(--accent-gold);
            border-radius: 10px;
            padding: 12px;
            min-width: 180px;
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.3);
        }

        .music-control-btn {
            background: rgba(212, 175, 55, 0.2);
            border: 1px solid var(--accent-gold);
            color: var(--accent-gold);
            padding: 6px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s;
            font-weight: bold;
        }

        .music-control-btn:hover {
            background: var(--accent-gold);
            color: #000;
        }

    </style>
</head>
<body>

    <!-- Background Canvas -->
    <canvas id="stars-canvas"></canvas>
    <div id="fog-layer"></div>

    <div id="asset-loader">
        <div style="font-size: 1.25rem; color: var(--accent-gold); letter-spacing: 2px;">ËµÑÊ∫êÂä†ËΩΩ‰∏≠ ¬∑ v2026-01-31-01</div>
        <div id="asset-progress-text" style="color: #ddd; font-size: 0.95rem;">0%</div>
        <div id="asset-progress-container">
            <div id="asset-progress-bar"></div>
        </div>
        <button id="asset-retry-btn" class="btn" style="display:none">ÈáçËØïÂä†ËΩΩ</button>
    </div>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="settings-btn">
            <svg viewBox="0 0 24 24" width="24" height="24" fill="currentColor">
                <path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/>
            </svg>
        </div>
        <div id="hand-cursor"></div>
        <div id="charge-ring"></div>
        <div id="header">
            <h1>Á•ûÁßòÂ°îÁΩó</h1>
            <div id="status-text">Ê≠£Âú®ÂêØÂä®...</div>
            <div id="charge-progress-container">
                <div id="charge-progress-bar"></div>
            </div>
        </div>

        <div id="picked-zone">
            <div class="picked-slot" id="slot-0"></div>
            <div class="picked-slot" id="slot-1"></div>
            <div class="picked-slot" id="slot-2"></div>
        </div>

        <!-- Token Input Removed -->

        <div id="gesture-guide">
            <div id="zone-left" class="guide-zone">ÂêëÂè≥Êå•Âä® ‚û°</div>
            <div id="zone-right" class="guide-zone">‚¨Ö ÂêëÂ∑¶Êå•Âä®</div>
            <div id="zone-center" class="guide-zone">
                <div class="guide-icon" id="icon-select">‚úä</div>
                <div style="font-size: 1rem; margin-top: 10px; text-shadow: 0 0 5px black;">Êè°Êã≥ÈÄâÁâå</div>
            </div>
        </div>

        <div id="controls">
            <button id="start-btn" class="btn" style="display:none">ÂºÄÂßã‰ΩìÈ™å</button>
            <button id="interpret-btn" class="btn" style="display:none; background: linear-gradient(45deg, #d4af37, #f0e68c); color: #000; font-weight: bold; box-shadow: 0 0 20px rgba(212,175,55,0.6);">üîÆ Ëß£ËØªÂëΩËøê</button>
            <div class="spinner" id="loading-spinner"></div>
        </div>
    </div>

    <video id="webcam-preview" playsinline></video>

    <!-- 3D Scene -->
    <div id="game-container">
        <div id="scene">
            <!-- Cards will be injected here -->
        </div>
    </div>

    <!-- Question Modal -->
    <div id="question-modal">
        <h2>üìù ÊèêÂá∫ÊÇ®ÁöÑÈóÆÈ¢ò</h2>
        <div class="question-subtitle">Âú®Ê¥óÁâå‰πãÂâçÔºåËØ∑Â∞ÜÊÇ®ÂøÉ‰∏≠ÁöÑÁñëÈóÆËØâËØ¥‰∫éÂ°îÁΩó...</div>
        <textarea id="user-question-input" placeholder="‰æãÂ¶ÇÔºöÊàëÂú®Â∑•‰Ωú‰∏≠Â∫îËØ•ÂÅöÂá∫‰ªÄ‰πàÊîπÂèòÔºüÊàñËÄÖÊàëÁöÑÊÑüÊÉÖ‰ºöÂ¶Ç‰ΩïÂèëÂ±ïÔºü..."></textarea>
        <div id="question-modal-buttons">
            <button class="btn" onclick="skipQuestion()">Ë∑≥Ëøá</button>
            <button class="btn" onclick="submitQuestion()">Á°ÆËÆ§</button>
        </div>
    </div>

    <!-- Interpretation Modal -->
    <div id="interpretation-modal">
        <h2 style="color: var(--accent-gold); text-align: center; margin-top: 0;">ÂëΩËøêÂêØÁ§∫</h2>
        <div id="interpretation-timer" style="color: var(--accent-gold); text-align: center; margin-bottom: 15px; font-style: italic; min-height: 1.2em;"></div>
        <div id="interpretation-content"></div>
        <div style="text-align: center; margin-top: 30px;">
            <button class="btn" style="margin-right: 10px; display: none;" id="quick-show-btn" onclick="renderFullContent()">Á´ãÂç≥ÊòæÁ§∫ÂÖ®Êñá</button>
            <button class="btn" style="margin-right: 10px; display: none;" id="interpret-music-btn" onclick="triggerMusicFromInterpretation()">üéµ ÁñóÊÑàÈü≥‰πê</button>
            <button class="btn" onclick="closeInterpretationModal()">ÂÖ≥Èó≠</button>
        </div>
    </div>

    <!-- Music Recommendation Modal -->
    <div id="music-recommendation-modal">
        <h2>üéµ ÂøÉÁÅµÈü≥‰πêÁñóÊÑà‰πãÊóÖ</h2>
        <div class="music-intro">Ê†πÊçÆÊÇ®ÁöÑÂ°îÁΩóÂëΩËøêÊåáÂºï‰∏éÂÜÖÂøÉÊÑüÂèóÔºå‰∏∫ÊÇ®Á≤æÈÄâ10È¶ñÊ≤ªÊÑà‰πãÊ≠å</div>
        <div id="music-list"></div>
        <div id="music-actions" style="text-align: center;">
            <button class="btn" onclick="copyAllSongs()">üìã Â§çÂà∂ÂÖ®ÈÉ®Ê≠åÊõ≤</button>
            <button class="btn" onclick="showLocationRecommendation()">üìç ÂèëÁé∞ÈôÑËøëÊ≤ªÊÑàÂú∞ÁÇπ</button>
            <button class="btn" onclick="closeMusicModal()">ÂÖ≥Èó≠</button>
        </div>
    </div>

    <!-- Location Recommendation Modal -->
    <div id="location-recommendation-modal">
        <h2>üìç ÈôÑËøëÂøÉÊÉÖÊ≤ªÊÑàÂú∞ÁÇπ</h2>
        <div class="location-intro">Ê†πÊçÆÊÇ®ÁöÑÂ°îÁΩóÊåáÂºïÔºå‰∏∫ÊÇ®Êé®ËçêÈôÑËøëËÉΩÁºìËß£ÂøÉÊÉÖÁöÑÂ∫óÈì∫ÂíåËÆæÊñΩ</div>
        <div id="location-map-container"></div>
        <div id="location-list"></div>
        <div id="location-actions" style="text-align: center;">
            <button class="btn" onclick="openMapNavigation()">üó∫Ô∏è Âú®Âú∞Âõæ‰∏≠ÊâìÂºÄ</button>
            <button class="btn" onclick="closeLocationModal()">ÂÖ≥Èó≠</button>
        </div>
    </div>

    <!-- Audio Elements -->
    <audio id="bg-music" loop>
        <!-- ÂõûÈÄÄÔºöÂµåÂÖ•‰∏ÄÊÆµÊûÅÁü≠ÁöÑÊó†ÁâàÊùÉÁéØÂ¢ÉÈü≥ÔºàWAV Êï∞ÊçÆÔºâÔºåÁî®‰∫éÁ°Æ‰øùÁÇπÂáªÊí≠ÊîæÊúâÂ£∞Èü≥ -->
        <source src="data:audio/wav;base64,UklGRkQAAABXQVZFZm10IBAAAAABAAEAQB8AAAB9AAACABAAZGF0YQwAAAAAAP8AAP8AAP8AAP8AAP8AAP8AAP8AAP8AAP8AAP8AAP8AAP8AAP8AAP8AAP8AAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==" type="audio/wav">
    </audio>
    <audio id="card-select-sound">
        <source src="data:audio/wav;base64,UklGRiYAAABXQVZFZm10IBAAAAABAAEAQB8AAAB9AAACABAAZGF0YCIAAAAAAAA=" type="audio/wav">
    </audio>
    
    <!-- ÂµåÂÖ•ÂºèÈü≥‰πêÊí≠ÊîæÂô® -->
    <div id="embedded-music-player" style="display: none;">
        <div class="player-header">
            <span id="current-song-title">Êú™Êí≠Êîæ</span>
            <button onclick="closeMusicPlayer()" style="background: none; border: none; color: white; cursor: pointer; font-size: 20px;">‚úï</button>
        </div>
        <audio id="music-player-audio" controls style="width: 100%;"></audio>
        <div class="player-info" id="current-song-info"></div>
    </div>

    <!-- Music Player Overlay -->
    <div id="music-player">
        <button id="music-toggle-btn" title="Toggle Music">üîä</button>
        <div id="music-player-panel" style="display:none;">
            <div style="color: var(--accent-gold); font-size: 0.9rem; margin-bottom: 10px;">Èü≥‰πêÊí≠Êîæ</div>
            <div style="display:flex; gap: 5px; flex-wrap: wrap;">
                <button id="play-btn" class="music-control-btn" style="flex:1;min-width:60px;">‚ñ∂ Êí≠Êîæ</button>
                <button id="pause-btn" class="music-control-btn" style="flex:1;min-width:60px;">‚è∏ ÊöÇÂÅú</button>
                <button id="mute-btn" class="music-control-btn" style="flex:1;min-width:60px;">üîá ÈùôÈü≥</button>
            </div>
            <input type="range" id="music-volume" min="0" max="100" value="50" style="width:100%; margin-top:10px;" title="Volume">
            <div style="font-size:0.8rem; color:#aaa; margin-top:5px;">Èü≥Èáè: <span id="volume-display">50</span>%</div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="settings-content">
            <h2 style="color: var(--accent-gold);">API Key ÈÖçÁΩÆ ÔºàÊú¨Âú∞Â≠òÂÇ®Ôºâ</h2>
            <p>ËØ∑ËæìÂÖ•ÊÇ®ÁöÑ DeepSeek API Key ‰ª•ÂºÄÂêØ AI Ëß£ËØªÂäüËÉΩ„ÄÇ</p>
            <p style="font-size: 0.9rem; color: #aaa;">
                ËøòÊ≤°Êúâ KeyÔºüÂâçÂæÄ <a href="https://platform.deepseek.com/api_keys" target="_blank">DeepSeek Platform</a> Ëé∑Âèñ„ÄÇ
            </p>
            <input type="password" id="api-token-input" placeholder="sk-...">
            <div id="token-status" style="font-size: 0.8rem; margin: 10px 0; min-height: 1.2em;"></div>
            <button id="save-settings-btn" class="btn">‰øùÂ≠òÈÖçÁΩÆ</button>
            <button id="close-settings-btn" class="btn" style="background: transparent; border: 1px solid #444; margin-top: 10px;">ÂÖ≥Èó≠</button>
        </div>
    </div>

    <script>
        // --- Audio System ---
        class AudioManager {
            constructor() {
                this.bgMusic = document.getElementById('bg-music');
                this.cardSelectSound = document.getElementById('card-select-sound');
                this.musicPlayer = document.getElementById('music-player');
                this.toggleBtn = document.getElementById('music-toggle-btn');
                this.playerPanel = document.getElementById('music-player-panel');
                this.playBtn = document.getElementById('play-btn');
                this.pauseBtn = document.getElementById('pause-btn');
                this.muteBtn = document.getElementById('mute-btn');
                this.volumeSlider = document.getElementById('music-volume');
                this.volumeDisplay = document.getElementById('volume-display');
                
                this.isMuted = false;
                this.currentVolume = 0.5;
                // WebAudio ÁéØÂ¢ÉÂ£∞ÂõûÈÄÄ
                this._ambientCtx = null;
                this._ambientOsc = null;
                this._usingAmbient = false;
                
                this.initEventListeners();
                this.loadSettings();
                this.createCardSelectSound();
            }
            
            initEventListeners() {
                this.toggleBtn.addEventListener('click', () => {
                    this.playerPanel.style.display = 
                        this.playerPanel.style.display === 'none' ? 'block' : 'none';
                });
                
                this.playBtn.addEventListener('click', () => this.play());
                this.pauseBtn.addEventListener('click', () => this.pause());
                this.muteBtn.addEventListener('click', () => this.toggleMute());
                
                this.volumeSlider.addEventListener('input', (e) => {
                    this.setVolume(parseInt(e.target.value) / 100);
                });
                
                // Close panel when clicking outside
                document.addEventListener('click', (e) => {
                    if (!this.musicPlayer.contains(e.target)) {
                        this.playerPanel.style.display = 'none';
                    }
                });

                // ÂΩìÈü≥È¢ëÊ∫ê‰∏çÂèØÁî®ÊàñÊä•ÈîôÊó∂ÔºåËá™Âä®ÂàáÊç¢Âà∞ÁéØÂ¢ÉÂ£∞ÊñπÊ°à
                this.bgMusic.addEventListener('error', () => {
                    this._enableAmbient();
                });
            }
            
            loadSettings() {
                const savedVolume = localStorage.getItem('music_volume');
                if (savedVolume) {
                    this.setVolume(parseFloat(savedVolume));
                    this.volumeSlider.value = Math.round(parseFloat(savedVolume) * 100);
                    this.volumeDisplay.textContent = Math.round(parseFloat(savedVolume) * 100);
                }
            }
            
            setVolume(vol) {
                this.currentVolume = Math.max(0, Math.min(1, vol));
                this.bgMusic.volume = this.isMuted ? 0 : this.currentVolume;
                this.volumeSlider.value = Math.round(this.currentVolume * 100);
                this.volumeDisplay.textContent = Math.round(this.currentVolume * 100);
                localStorage.setItem('music_volume', this.currentVolume);
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                this.bgMusic.volume = this.isMuted ? 0 : this.currentVolume;
                this.muteBtn.style.background = this.isMuted ? 'rgba(255,100,100,0.3)' : 'rgba(212, 175, 55, 0.2)';
                this.muteBtn.style.borderColor = this.isMuted ? '#ff6464' : 'var(--accent-gold)';
                this.muteBtn.style.color = this.isMuted ? '#ff6464' : 'var(--accent-gold)';
            }
            
            play() {
                if (this._usingAmbient) {
                    this._startAmbient();
                    return;
                }
                this.bgMusic.play().catch(e => {
                    console.warn('Audio play failed:', e);
                    // Âá∫ÈîôÊó∂ÂêØÁî®ÁéØÂ¢ÉÂ£∞ÂõûÈÄÄÔºåÁ°Æ‰øù‚ÄúËÉΩÂê¨Âà∞Â£∞Èü≥‚Äù
                    this._enableAmbient();
                    this._startAmbient();
                });
            }
            
            pause() {
                try { this.bgMusic.pause(); } catch {}
                this._stopAmbient();
            }
            
            playCardSelectSound() {
                try {
                    // Reset and play card select sound
                    this.cardSelectSound.currentTime = 0;
                    this.cardSelectSound.play().catch(() => {
                        // Fallback to oscillator
                        this.playOscillatorSound(440, 0.1);
                    });
                } catch(e) {
                    console.warn('Card sound play failed:', e);
                }
            }
            
            createCardSelectSound() {
                // Create a simple beep sound using Web Audio API
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 800;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            }
            
            playOscillatorSound(frequency = 440, duration = 0.15) {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch(e) {
                    console.warn('Oscillator sound failed:', e);
                }
            }

            _enableAmbient() {
                if (!this._ambientCtx) {
                    try {
                        this._ambientCtx = new (window.AudioContext || window.webkitAudioContext)();
                        this._usingAmbient = true;
                    } catch (e) {
                        console.warn('Ambient AudioContext init failed:', e);
                    }
                }
            }

            _startAmbient() {
                if (!this._ambientCtx) return;
                this._stopAmbient();
                try {
                    const osc = this._ambientCtx.createOscillator();
                    const gain = this._ambientCtx.createGain();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(220, this._ambientCtx.currentTime);
                    gain.gain.setValueAtTime(this.isMuted ? 0 : this.currentVolume * 0.2, this._ambientCtx.currentTime);
                    osc.connect(gain);
                    gain.connect(this._ambientCtx.destination);
                    osc.start();
                    this._ambientOsc = osc;
                } catch (e) {
                    console.warn('Start ambient failed:', e);
                }
            }

            _stopAmbient() {
                try {
                    if (this._ambientOsc) {
                        this._ambientOsc.stop();
                        this._ambientOsc.disconnect();
                        this._ambientOsc = null;
                    }
                } catch {}
            }
        }
        
        // Initialize audio manager
        let audioManager = null;
        
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                audioManager = new AudioManager();
            });
        } else {
            audioManager = new AudioManager();
        }

        // --- 1. Card Data & Configuration ---
        const ASSETS_PATH = 'assets/tarot/pkt/';
        
        // Helper to generate full card list
        const generateCards = () => {
            const cards = [];
            
            // Major Arcana
            const majorNames = [
                "The Fool", "The Magician", "The High Priestess", "The Empress", "The Emperor", 
                "The Hierophant", "The Lovers", "The Chariot", "Strength", "The Hermit", 
                "Wheel of Fortune", "Justice", "The Hanged Man", "Death", "Temperance", 
                "The Devil", "The Tower", "The Star", "The Moon", "The Sun", 
                "Judgement", "The World"
            ];
            
            majorNames.forEach((name, i) => {
                const id = `ar${String(i).padStart(2, '0')}`;
                cards.push({ id, name, type: 'major', img: `${ASSETS_PATH}${id}.jpg` });
            });

            // Minor Arcana
            const suits = [
                { code: 'wa', name: 'Wands' },
                { code: 'cu', name: 'Cups' },
                { code: 'sw', name: 'Swords' },
                { code: 'pe', name: 'Pentacles' }
            ];
            
            const ranks = [
                { code: 'ac', name: 'Ace' },
                { code: '02', name: 'Two' }, { code: '03', name: 'Three' }, { code: '04', name: 'Four' },
                { code: '05', name: 'Five' }, { code: '06', name: 'Six' }, { code: '07', name: 'Seven' },
                { code: '08', name: 'Eight' }, { code: '09', name: 'Nine' }, { code: '10', name: 'Ten' },
                { code: 'pa', name: 'Page' }, { code: 'kn', name: 'Knight' }, { code: 'qu', name: 'Queen' }, { code: 'ki', name: 'King' }
            ];

            suits.forEach(suit => {
                ranks.forEach(rank => {
                    const id = `${suit.code}${rank.code}`;
                    cards.push({
                        id,
                        name: `${rank.name} of ${suit.name}`,
                        type: 'minor',
                        img: `${ASSETS_PATH}${id}.jpg`
                    });
                });
            });

            return cards;
        };

        const FULL_DECK = generateCards();
        console.log("üé¥ FULL_DECK Â∑≤ÁîüÊàê:", FULL_DECK.length, "Âº†Âç°Áâå");
        if (FULL_DECK.length > 0) {
            console.log("üìç Á¨¨‰∏ÄÂº†Âç°Áâå:", FULL_DECK[0]);
            console.log("üìç ÊúÄÂêé‰∏ÄÂº†Âç°Áâå:", FULL_DECK[FULL_DECK.length - 1]);
        }
        
        let currentDeck = [];
        let pickedCards = []; // { card, reversed, position }
        let assetsReady = false;
        let assetsFailed = false;
        let cameraReady = false;
        let cameraError = false;

        function setAssetProgress(progress, label) {
            // Accept either a percentage number (0-100) or a fractional value
            let pct = parseFloat(progress) || 0;
            // If caller passed a fraction (0..1), convert to percent
            if (pct > 0 && pct <= 1) pct = pct * 100;
            pct = Math.max(0, Math.min(100, pct));
            const text = document.getElementById('asset-progress-text');
            const bar = document.getElementById('asset-progress-bar');
            // Show one decimal to avoid long periods showing exactly "0%"
            const display = pct < 0.1 && pct > 0 ? pct.toFixed(2) : pct.toFixed(1);
            if (text) text.innerText = label ? `${label} ${display}%` : `${display}%`;
            if (bar) bar.style.width = `${pct}%`;
            console.log(`üìä ËøõÂ∫¶: ${display}% (${label})`);
        }

        function updateIdleStatus() {
            if (currentState !== STATE.IDLE) return;
            if (cameraError) return;
            const status = document.getElementById('status-text');
            if (!status) return;
            if (assetsFailed) {
                status.innerText = "ËµÑÊ∫êÂä†ËΩΩÂ§±Ë¥•ÔºåÁÇπÂáªÈáçËØï";
                return;
            }
            if (!assetsReady) {
                status.innerText = "ËµÑÊ∫êÂä†ËΩΩ‰∏≠...";
                return;
            }
            if (cameraReady) {
                status.innerText = "Âº†ÂºÄ‰Ω†ÁöÑ‰∫îÊåáÂºÄÂßã";
            }
        }

        function preloadDeckAssets() {
            const loader = document.getElementById('asset-loader');
            const retryBtn = document.getElementById('asset-retry-btn');
            if (retryBtn) retryBtn.style.display = 'none';
            if (loader) loader.style.display = 'flex';

            assetsReady = false;
            assetsFailed = false;
            setAssetProgress(5, "ÂàùÂßãÂåñËµÑÊ∫ê");
            updateIdleStatus();

            // Set a failsafe timeout to hide loader if it gets stuck
            const failsafeTimeout = setTimeout(() => {
                if (!assetsReady) {
                    console.warn("‚ö†Ô∏è ËµÑÊ∫êÂä†ËΩΩË∂ÖÊó∂ÔºåÂº∫Âà∂ÂºÄÂêØÂ∫îÁî®...");
                    assetsReady = true;
                    if (loader) loader.style.display = 'none';
                    updateIdleStatus();
                }
            }, 12000); // 12ÁßíÂº∫Ë°åËøõÂÖ•Ê∏∏Êàè

            const images = FULL_DECK.map(c => c.img).filter(Boolean);
            const uniqueImages = Array.from(new Set(images));
            const total = uniqueImages.length;
            console.log(`ÂºÄÂßãÂä†ËΩΩ ${total} Âº†ÂõæÁâá`, uniqueImages.slice(0, 3));
            let doneCount = 0;
            let failCount = 0;
            if (total === 0) {
                console.warn("Êú™Ê£ÄÊµãÂà∞ÂõæÁâáÂàóË°®");
                assetsReady = true;
                if (loader) loader.style.display = 'none';
                updateIdleStatus();
                return;
            }

            // Faster page readiness strategy:
            // 1) Load a small initial batch (ÂÖ≥ÈîÆÂõæÁâá) Âπ∂Âú®ÂÆÉ‰ª¨Âä†ËΩΩÂÆåÊàêÂêéÂ∞ΩÂø´ÈöêËóèÂä†ËΩΩÈÅÆÁΩ©ÔºåÊèêÂçáÈ¶ñÂ±èÈÄüÂ∫¶„ÄÇ
            // 2) ÂÖ∂‰ΩôÂõæÁâáÂú®ÂêéÂè∞‰ª•ÈôêÂπ∂ÂèëÊñπÂºèÁªßÁª≠Âä†ËΩΩ„ÄÇ
            const CONCURRENCY = 6;
            const INITIAL_LOAD_COUNT = Math.min(12, total); // ÂÖàÂä†ËΩΩÁöÑÂÖ≥ÈîÆÊï∞Èáè
            let progressAnimationId = null;

            // Animate progress even if images are slow to respond
            function animateProgress() {
                if (progressAnimationId) return;
                let fakeProgress = 5; // ‰ªé 5% ÂºÄÂßãÔºåËÄå‰∏çÊòØ 0%

                progressAnimationId = setInterval(() => {
                    const realProgress = ((doneCount + failCount) / total) * 100;
                    if (realProgress > fakeProgress) {
                        fakeProgress = realProgress;
                    } else if (fakeProgress < 99 && (doneCount + failCount) > 0) {
                        fakeProgress = Math.min(fakeProgress + 0.3, 99); // Slow progress animation
                    }
                    
                    // ‰ªÖÂΩì fakeProgress ÊòæËëóÂ§ß‰∫é 0 Êó∂Êõ¥Êñ∞
                    if (fakeProgress > 1) {
                        setAssetProgress(fakeProgress, "Âä†ËΩΩÊòüËæ∞‰∏≠");
                    }
                }, 100);
            }

            // Promise-based image loader with timeout
            function loadImage(src) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.decoding = 'async';
                    let timeout = setTimeout(() => {
                        console.warn(`‚è± Âä†ËΩΩË∂ÖÊó∂: ${src}`);
                        failCount += 1;
                        setAssetProgress(((doneCount + failCount) / total) * 100);
                        resolve({ src, ok: false });
                    }, 8000); // 8 second timeout per image

                    img.onload = () => {
                        clearTimeout(timeout);
                        doneCount += 1;
                        setAssetProgress(((doneCount + failCount) / total) * 100);
                        console.log(`‚úì Âä†ËΩΩÊàêÂäü: ${src} (${doneCount}/${total})`);
                        resolve({ src, ok: true });
                    };
                    img.onerror = () => {
                        clearTimeout(timeout);
                        failCount += 1;
                        setAssetProgress(((doneCount + failCount) / total) * 100);
                        console.warn(`‚úó Âä†ËΩΩÂ§±Ë¥•: ${src}`);
                        resolve({ src, ok: false });
                    };
                    // Kick off load
                    img.src = src;
                });
            }

            // Concurrency-limited pool
            async function loadPool(list, concurrency) {
                let idx = 0;
                const workers = new Array(concurrency).fill(0).map(async () => {
                    while (idx < list.length) {
                        const i = idx++;
                        await loadImage(list[i]);
                    }
                });
                await Promise.all(workers);
            }

            // Load initial batch first to make app interactive quickly
            const initialList = uniqueImages.slice(0, INITIAL_LOAD_COUNT);
            const remainingList = uniqueImages.slice(INITIAL_LOAD_COUNT);

            // Start progress animation immediately
            animateProgress();

            // Start initial load synchronously (await) so we can hide loader asap
            loadPool(initialList, Math.min(CONCURRENCY, initialList.length)).then(() => {
                // If too many failures in initial batch, show retry
                const initialFails = failCount;
                const failThreshold = Math.max(2, Math.floor(INITIAL_LOAD_COUNT * 0.25));
                if (initialFails > failThreshold) {
                    clearInterval(progressAnimationId);
                    assetsFailed = true;
                    setAssetProgress(100, "Âä†ËΩΩÂ§±Ë¥•");
                    if (retryBtn) retryBtn.style.display = 'inline-block';
                    if (retryBtn) retryBtn.onclick = () => preloadDeckAssets();
                    updateIdleStatus();
                    return;
                }

                // Mark ready for interaction once initial batch loaded
                assetsReady = true;
                clearInterval(progressAnimationId);
                setAssetProgress(Math.min(100, ((doneCount + failCount) / total) * 100), "È¶ñÊâπÂä†ËΩΩÂÆåÊàê");
                if (loader) loader.style.display = 'none';
                updateIdleStatus();

                // Load remaining in background without blocking UI
                if (remainingList.length > 0) {
                    // Fire-and-forget
                    loadPool(remainingList, CONCURRENCY).then(() => {
                        // Final check when background loading completes
                        if (failCount > 0) {
                            // Do not forcibly block user, but surface retry when many failed
                            const failRatio = failCount / total;
                            if (failRatio > 0.15 && retryBtn) {
                                retryBtn.style.display = 'inline-block';
                                retryBtn.onclick = () => preloadDeckAssets();
                            }
                        }
                        // set progress to complete
                        setAssetProgress(100, 'Âä†ËΩΩÂÆåÊàê');
                    });
                } else {
                    // No remaining images
                    setAssetProgress(100, 'Âä†ËΩΩÂÆåÊàê');
                }
            });
        }
        
        // --- 2. Game State & Logic ---
        const STATE = {
            IDLE: 'IDLE',
            QUESTION: 'QUESTION',
            INTRO: 'INTRO',
            PICKING: 'PICKING',
            REVEALING: 'REVEALING',
            INTERPRETING: 'INTERPRETING'
        };

        let currentState = STATE.IDLE;
        let userQuestion = ''; // Store user's question
        // Interpretation cache & flags (‰∏ÄÊ¨°Â°îÁΩóÁâå‰ªÖËß£ËØª‰∏ÄÊ¨°)
        let hasInterpretedForCurrentDraw = false;
        let cachedInterpretationText = '';
        let isFetchingInterpretation = false;
        const ENABLE_PALM_INTERPRETATION = false; // ÂÖ≥Èó≠Âº†ÊâãËß¶ÂèëËß£ËØª
        
        // Navigation State
        let currentIndex = 0;   // Current float index (physics object)
        let velocity = 0;       // Current scroll velocity
        let isDragging = false; // Is the user actively moving?
        
        // --- 3. 3D Scene & Rendering ---
        const scene = document.getElementById('scene');
        
        function initStars() {
            const canvas = document.getElementById('stars-canvas');
            const ctx = canvas.getContext('2d');
            
            let width, height, stars = [];
            
            function resize() {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
                stars = [];
                for(let i=0; i<200; i++) {
                    stars.push({
                        x: Math.random() * width,
                        y: Math.random() * height,
                        size: Math.random() * 2,
                        opacity: Math.random(),
                        speed: Math.random() * 0.5
                    });
                }
            }
            
            function animate() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'white';
                
                stars.forEach(star => {
                    ctx.globalAlpha = star.opacity;
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    star.y -= star.speed;
                    if(star.y < 0) star.y = height;
                    
                    // Twinkle
                    if(Math.random() > 0.95) star.opacity = Math.random();
                });
                
                requestAnimationFrame(animate);
            }
            
            window.addEventListener('resize', resize);
            resize();
            animate();
        }

        // Shuffle Array
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function createCardElement(card, index) {
            const wrapper = document.createElement('div');
            wrapper.className = 'card-wrapper';
            wrapper.dataset.index = index;
            
            const inner = document.createElement('div');
            inner.className = 'card-inner';
            
            const back = document.createElement('div');
            back.className = 'card-face card-back';
            
            const front = document.createElement('div');
            front.className = 'card-face card-front';
            front.style.backgroundImage = `url('${card.img}')`;
            
            inner.appendChild(back);
            inner.appendChild(front);
            wrapper.appendChild(inner);
            
            return wrapper;
        }

        function renderDeck() {
            scene.innerHTML = '';
            
            // Render logic based on state
            if (currentState === STATE.PICKING || currentState === STATE.INTRO) {
                // Render a fan or spread of cards
                // For simplicity and "coolness", we use a horizontal carousel
                
                currentDeck.forEach((card, i) => {
                    const el = createCardElement(card, i);
                    scene.appendChild(el);
                });
                updateCardPositions();
            } else if (currentState === STATE.REVEALING || currentState === STATE.INTERPRETING) {
                // Render only picked cards centered
                pickedCards.forEach((item, i) => {
                    const el = createCardElement(item.card, i);
                    // Add picked specific styles if needed
                    el.classList.add('picked-card');
                    // Immediately flip if revealed
                    // Logic handled in updatePickedPositions
                    scene.appendChild(el);
                });
                updatePickedPositions();
            }
        }

        function updateCardPositions() {
            if (currentState !== STATE.PICKING && currentState !== STATE.INTRO) return;

            const cards = document.querySelectorAll('.card-wrapper');
            const width = window.innerWidth;
            
            // Responsive Layout Calculation
            // Base gap + factor of screen width
            // This ensures on wide screens cards are spread out more
            const cardWidthVar = getComputedStyle(document.documentElement).getPropertyValue('--card-width').trim();
            const cardWidthPx = parseFloat(cardWidthVar) || 200;
            const compactMedia = window.matchMedia && window.matchMedia('(orientation: landscape) and (max-height: 520px)').matches;
            const isMobile = width <= 480 || compactMedia;
            const gap = Math.min(
                Math.max(cardWidthPx * (isMobile ? 0.85 : 1.15), width * (isMobile ? 0.12 : 0.18)),
                cardWidthPx * (isMobile ? 1.25 : 2)
            );
            
            // Calculate how many cards to show based on screen width
            // Due to Z-depth, cards shrink, so we need more margin
            // If gap is 300, and width is 1920 (half 960), we need ~3.2 cards.
            // But Z-depth makes them squeeze. Let's be generous.
            const visibleSideCount = Math.ceil((width / 2) / (gap * 0.5)) + 3;
            
            cards.forEach((card, i) => {
                // Check if card is already picked
                if (card.classList.contains('picked')) {
                    return; // Skip positioning logic for picked cards
                }

                const dist = i - currentIndex;
                
                if (Math.abs(dist) > visibleSideCount) {
                    card.style.display = 'none';
                    return;
                } else {
                    card.style.display = 'block';
                }

                const x = dist * gap;
                // Reduce Z-depth dropoff to keep peripheral cards larger/closer
                const z = -Math.pow(Math.abs(dist), 1.3) * 50; 
                
                // Reduced rotation to keep back visible (prevent face peeking)
                // Clamp rotation to max 45 degrees
                let rotateY = dist * 5; 
                if (rotateY > 45) rotateY = 45;
                if (rotateY < -45) rotateY = -45;
                
                let scale = 1;
                const isSelected = Math.round(currentIndex) === i;
                
                if (Math.abs(dist) < 0.5) {
                    const selectedScaleBase = isMobile ? 1.06 : 1.2;
                    const selectedScaleFalloff = isMobile ? 0.22 : 0.4;
                    scale = selectedScaleBase - Math.abs(dist) * selectedScaleFalloff;
                    card.style.zIndex = 1000;
                } else {
                    // Less aggressive scaling down for side cards
                    scale = 1 - Math.min(Math.abs(dist) * 0.08, 0.4);
                    card.style.zIndex = 1000 - Math.floor(Math.abs(dist) * 10);
                }
                
                if (isSelected) {
                     card.classList.add('selected');
                } else {
                     card.classList.remove('selected');
                }

                if (isFistHeld && chargeTargetIndex !== null && i === chargeTargetIndex) {
                    scale *= chargeExtraScale;
                    card.style.zIndex = 2000;
                }
                
                card.style.transform = `translateX(${x}px) translateZ(${z}px) rotateY(${rotateY}deg) scale(${scale})`;
            });
        }

        function updatePickedPositions() {
            const cards = document.querySelectorAll('.card-wrapper');
            
            // Responsive spacing for picked cards
            const width = window.innerWidth;
            const compactMedia = window.matchMedia && window.matchMedia('(orientation: landscape) and (max-height: 520px)').matches;
            const spread = (width <= 480 || compactMedia) ? Math.min(width * 0.18, 180) : Math.min(width * 0.3, 400);
            
            const positions = [-spread, 0, spread];
            const labels = ["ËøáÂéª", "Áé∞Âú®", "Êú™Êù•"];
            
            cards.forEach((card, i) => {
                const x = positions[i];
                // If this card is revealed, flip it
                if (i < pickedCards.length) {
                    const picked = pickedCards[i];
                    // Reveal animation
                    setTimeout(() => {
                        card.classList.add('flipped');
                        // Add reversed visual if needed
                        if (picked.reversed) {
                            // Find the front face and rotate it
                            const front = card.querySelector('.card-front');
                            if (front) {
                                front.style.transform = 'rotateX(180deg)'; // Flip upside down
                            }
                        }
                    }, i * 500 + 500); // Staggered reveal
                }
                
                card.style.transform = `translateX(${x}px) scale(1.1)`;
                card.style.zIndex = 10;
                
                // Add label if not exists
                if (!card.querySelector('.label')) {
                    const label = document.createElement('div');
                    label.className = 'label';
                    label.innerText = labels[i];
                    label.style.position = 'absolute';
                    label.style.bottom = '-40px';
                    label.style.width = '100%';
                    label.style.textAlign = 'center';
                    label.style.color = '#d4af37';
                    label.style.textShadow = '0 0 5px black';
                    label.style.fontSize = '1.2rem';
                    card.appendChild(label);
                }
            });
        }

        // --- 4. Controls & Hand Gestures ---
        let lastHandX = -1;
        let lastHandY = -1; // Track Y for cursor
        
        // Selection State
        let fistHoldStart = 0;
        let isFistHeld = false;
        let lockedSelectIndex = null;
        let chargeTargetIndex = null;
        let chargeExtraScale = 1;
        const SELECTION_HOLD_TIME = 1000; // 1 second as requested

        // Interpretation Gesture State
        let isPalmHeld = false;
        let palmHoldStart = 0;
        const INTERPRET_HOLD_TIME = 1000; // 1ÁßíËØÜÂà´ÔºåÊèêÈ´òÁÅµÊïèÂ∫¶

        // Physics Constants
        const FRICTION = 0.92;
        const SENSITIVITY = 1.0; // Reduced for slower, controlled scrolling
        const MAX_VELOCITY = 0.25; // Lower cap speed
        
        function isFist(landmarks) {
            // Check fingertips (8, 12, 16, 20) distance to wrist (0)
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let avgDist = 0;
            
            tips.forEach(idx => {
                const tip = landmarks[idx];
                const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                avgDist += d;
            });
            avgDist /= tips.length;
            
            // Threshold for fist (tuned for normalized coordinates)
            return avgDist < 0.23; 
        }

        function isOpenPalm(landmarks) {
             // Check fingertips (8, 12, 16, 20) distance to wrist (0)
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            let avgDist = 0;
            
            tips.forEach(idx => {
                const tip = landmarks[idx];
                const d = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
                avgDist += d;
            });
            avgDist /= tips.length;
            
            // Threshold for open palm (fingers extended) - Èôç‰ΩéÈòàÂÄºÊèêÈ´òÁÅµÊïèÂ∫¶
            return avgDist > 0.3; 
        }

        function spawnChargeParticles(rect) {
            const x = rect.left + rect.width / 2;
            const y = rect.top + rect.height / 2;
            
            // Spawn multiple particles
            for(let i=0; i<2; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                
                // Random offset within card area
                const ox = (Math.random() - 0.5) * rect.width * 0.9;
                const oy = (Math.random() - 0.5) * rect.height * 0.9;
                
                p.style.left = (x + ox) + 'px';
                p.style.top = (y + oy) + 'px';
                
                // Varied properties
                const size = 2 + Math.random() * 6;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                
                if(Math.random() > 0.6) {
                    p.style.background = 'var(--accent-gold)';
                    p.style.boxShadow = '0 0 8px var(--accent-gold)';
                }
                
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 800);
            }
        }

        function spawnInterpretationParticles() {
            for (let i = 0; i < 5; i++) {
                const p = document.createElement('div');
                p.className = 'particle';
                
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight;
                
                p.style.left = x + 'px';
                p.style.top = y + 'px';
                
                const size = 3 + Math.random() * 8;
                p.style.width = size + 'px';
                p.style.height = size + 'px';
                
                p.style.background = 'var(--accent-gold)';
                p.style.boxShadow = '0 0 10px var(--accent-gold)';
                p.style.opacity = '0.8';
                p.style.zIndex = '9999';
                
                // Animation: Float up
                p.animate([
                    { transform: 'translateY(0) scale(1)', opacity: 0.8 },
                    { transform: `translateY(-100px) scale(0)`, opacity: 0 }
                ], {
                    duration: 1000 + Math.random() * 1000,
                    easing: 'ease-out'
                });
                
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 2000);
            }
        }

        function spawnTrail(x, y) {
            const trail = document.createElement('div');
            trail.className = 'cursor-trail';
            trail.style.left = x + 'px';
            trail.style.top = y + 'px';
            // Random colors for coolness
            const hue = (Date.now() / 10) % 360;
            trail.style.background = `hsla(${hue}, 80%, 60%, 0.8)`;
            trail.style.boxShadow = `0 0 10px hsla(${hue}, 80%, 60%, 0.8)`;
            document.body.appendChild(trail);
            setTimeout(() => trail.remove(), 500);
        }

        function updateChargeVisuals(isActive, x, y, progress) {
            const ring = document.getElementById('charge-ring');
            // Disable ring visual as requested (red circle)
            ring.style.opacity = '0';
            ring.style.display = 'none';
            return;
            
            /* Previous logic disabled
            if (!isActive) {
                ring.style.opacity = '0';
                ring.style.transform = `translate(-50%, -50%) scale(0)`;
                return;
            }
            
            ring.style.left = x + 'px';
            ring.style.top = y + 'px';
            ring.style.opacity = '1';
            // Scale from 0.5 to 1.5 based on progress
            const scale = 0.5 + progress; 
            ring.style.transform = `translate(-50%, -50%) scale(${scale})`;
            
            // Change color based on progress
            const r = 212 + (255-212)*progress;
            const g = 175 - 175*progress; // Turn redder? Or whiter? Let's go Gold to White
            const b = 55 + (255-55)*progress;
            ring.style.borderColor = `rgb(${r},${g},${b})`;
            */
        }

        function handleGesture(handLandmarks) {
            // Allow processing in INTERPRETING and IDLE state too
            if (currentState !== STATE.PICKING && currentState !== STATE.INTERPRETING && currentState !== STATE.IDLE) return;
            
            const palm = handLandmarks[9]; 
            const x = palm.x; 
            const y = palm.y;

            // Initialize lastHandX if needed
            if (lastHandX === -1) {
                lastHandX = x;
                lastHandY = y;
                return;
            }

            // Update Cursor Visuals
            const cursor = document.getElementById('hand-cursor');
            const screenX = (1 - x) * window.innerWidth; // Mirror X
            const screenY = y * window.innerHeight;
            
            cursor.style.display = 'block';
            cursor.style.left = screenX + 'px';
            cursor.style.top = screenY + 'px';

            // Always spawn trail for "cool" factor when moving
            const distMoved = Math.sqrt(Math.pow(x - lastHandX, 2) + Math.pow(y - lastHandY, 2));
            if (distMoved > 0.005) {
                spawnTrail(screenX, screenY);
            }

            // --- START & INTERPRETATION LOGIC ---
            if (currentState === STATE.IDLE || currentState === STATE.INTERPRETING) {
                const progressContainer = document.getElementById('charge-progress-container');
                const progressBar = document.getElementById('charge-progress-bar');
                
                if (isOpenPalm(handLandmarks)) {
                    if (!isPalmHeld) {
                        isPalmHeld = true;
                        palmHoldStart = Date.now();
                        // Show progress bar
                        progressContainer.style.display = 'block';
                        progressBar.style.width = '0%';
                    }
                    
                    const elapsed = Date.now() - palmHoldStart;
                    const progress = Math.min(elapsed / INTERPRET_HOLD_TIME, 1.0);
                    
                    // Visuals
                    if (Math.random() < 0.5) spawnInterpretationParticles();
                    
                    // Update Progress Bar
                    progressBar.style.width = (progress * 100) + '%';
                    
                    if (elapsed > INTERPRET_HOLD_TIME) {
                        // Trigger Action
                        if (currentState === STATE.IDLE) {
                            startGame();
                        } else if (currentState === STATE.INTERPRETING && ENABLE_PALM_INTERPRETATION) {
                            // Palm interpretation disabled as per user request
                            // const token = localStorage.getItem('deepseek_token');
                            // if (token) getAIInterpretation(token);
                        }
                        
                        // Reset vars but keep state (modal will handle overlay)
                        isPalmHeld = false;
                        palmHoldStart = 0;
                        progressContainer.style.display = 'none';
                    }
                } else {
                    if (isPalmHeld) {
                        isPalmHeld = false;
                        palmHoldStart = 0;
                        
                        // Reset Visuals
                        progressContainer.style.display = 'none';
                        progressBar.style.width = '0%';

                        if (currentState === STATE.IDLE) {
                             updateIdleStatus();
                        } else {
                             document.getElementById('status-text').innerText = "Âº†ÂºÄ‰Ω†ÁöÑ‰∫îÊåáÔºåËß£ËØªÁâåÈù¢";
                        }
                    }
                }
                lastHandX = x;
                lastHandY = y;
                return; // Skip picking logic
            }

            // --- ZONE BASED LOGIC (Replaced Movement Logic) ---
            const width = window.innerWidth;
            let targetV = 0;
            const MAX_SCROLL_SPEED = 0.2; // Max speed at edge of screen
            
            if (screenX < width * 0.33) {
                // LEFT ZONE (0 - 1/3)
                // Speed increases as we get closer to the left edge (0)
                const distFromCenter = (width * 0.33) - screenX;
                const maxDist = width * 0.33;
                const intensity = Math.min(distFromCenter / maxDist, 1.0); // 0 to 1
                
                targetV = -intensity * MAX_SCROLL_SPEED;
                highlightDirection('left');
            } else if (screenX > width * 0.66) {
                // RIGHT ZONE (2/3 - 1)
                // Speed increases as we get closer to the right edge (width)
                const distFromCenter = screenX - (width * 0.66);
                const maxDist = width * 0.34;
                const intensity = Math.min(distFromCenter / maxDist, 1.0); // 0 to 1
                
                targetV = intensity * MAX_SCROLL_SPEED;
                highlightDirection('right');
            } else {
                // CENTER ZONE (1/3 - 2/3)
                // Stop Scrolling
                targetV = 0;
                
                // Only clear highlights if not selecting
                if (!isFistHeld) resetHighlights();
            }
            
            // Smoothly interpolate velocity towards target
            // This prevents jerky starts/stops
            velocity = velocity * 0.8 + targetV * 0.2;

            // --- SELECTION LOGIC (Middle 1/3 + 1s Hold) ---
            const inCenterZone = screenX > width * 0.33 && screenX < width * 0.66;
            const fistDetected = isFist(handLandmarks);

            if (fistDetected && inCenterZone) {
                // Cursor stays same shape/color
                
                if (!isFistHeld) {
                    // Start Holding
                    isFistHeld = true;
                    fistHoldStart = Date.now();
                    lockedSelectIndex = Math.round(currentIndex);
                    chargeTargetIndex = lockedSelectIndex;
                    chargeExtraScale = 1;
                    highlightDirection('select');
                }
                
                // Calculate Progress
                const elapsed = Date.now() - fistHoldStart;
                const progress = Math.min(elapsed / SELECTION_HOLD_TIME, 1.0);
                chargeExtraScale = 1 + progress * 0.15;
                
                // Glow Effect on Target Card
                const targetIdx = lockedSelectIndex ?? Math.round(currentIndex);
                const cards = document.querySelectorAll('.card-wrapper');
                cards.forEach(card => {
                    if (parseInt(card.dataset.index) === targetIdx) {
                        // White glow increasing with progress - Intensified
                        const glowSize = 30 + (progress * 100);
                        const glowAlpha = 0.8 + (progress * 0.2); // Starts bright, stays bright
                        // Multiple layers for intense glow
                        card.style.boxShadow = `
                            0 0 ${glowSize}px rgba(255, 255, 255, ${glowAlpha}),
                            0 0 ${glowSize * 0.5}px rgba(255, 255, 255, 1),
                            inset 0 0 30px rgba(255, 255, 255, 0.5)
                        `;
                        card.style.filter = `brightness(${1 + progress * 1.5})`; // Make it blindingly bright
                        card.style.zIndex = 2000; // Ensure on top
                        
                        // Spawn Particles
                        spawnChargeParticles(card.getBoundingClientRect());
                        
                    } else {
                         // Reset others if needed, though usually handled in updateCardPositions
                         // We should let updateCardPositions handle base state, but here we override.
                         card.style.filter = ''; // Reset filter
                         card.style.boxShadow = ''; // Reset shadow
                    }
                });

                updateChargeVisuals(true, screenX, screenY, progress);
                
                if (elapsed > SELECTION_HOLD_TIME) {
                    // Trigger Selection
                    selectCard();
                    
                    // Reset
                    isFistHeld = false;
                    fistHoldStart = 0;
                    lockedSelectIndex = null;
                    chargeTargetIndex = null;
                    chargeExtraScale = 1;
                    updateChargeVisuals(false);
                    
                    // Cleanup any remaining glow immediately on select (or keep it as feedback?)
                    // Actually selectCard hides the card, so we are fine.
                    
                    // Success Burst
                    const ring = document.createElement('div');
                    ring.style.position = 'absolute';
                    ring.style.left = screenX + 'px';
                    ring.style.top = screenY + 'px';
                    ring.style.width = '100px';
                    ring.style.height = '100px';
                    ring.style.border = '4px solid white';
                    ring.style.borderRadius = '50%';
                    ring.style.transform = 'translate(-50%, -50%)';
                    ring.style.animation = 'pulseRing 0.5s ease-out'; 
                    document.body.appendChild(ring);
                    setTimeout(() => ring.remove(), 500);
                }
                
            } else {
                // cursor.classList.remove('grabbing');
                if (isFistHeld) {
                    // Cancelled
                    isFistHeld = false;
                    fistHoldStart = 0;
                    lockedSelectIndex = null;
                    chargeTargetIndex = null;
                    chargeExtraScale = 1;
                    updateChargeVisuals(false);
                    resetHighlights();
                    
                    // Reset card styles immediately
                    const cards = document.querySelectorAll('.card-wrapper');
                    cards.forEach(card => {
                        card.style.filter = '';
                        card.style.boxShadow = '';
                    });
                }
            }
            
            lastHandX = x;
            lastHandY = y;
        }

        let targetIndex = 0; // Target for intro animation

        function gameLoop() {
            if (currentState === STATE.INTRO) {
                // Smoothly interpolate currentIndex to targetIndex
                const dist = targetIndex - currentIndex;
                // Exponential ease out
                currentIndex += dist * 0.05;
                
                // Check if close enough to stop intro
                if (Math.abs(dist) < 0.1) {
                    currentIndex = targetIndex;
                    currentState = STATE.PICKING;
                    document.getElementById('status-text').innerText = "Êè°Êã≥ÈÄâ‰∏≠‰Ω†ÁöÑÂëΩËøê‰πãÁâå";
                    // Show picked zone slots
                    document.getElementById('picked-zone').style.display = 'flex';
                }
                updateCardPositions();
            }
            
            if (currentState === STATE.PICKING) {
                if (isFistHeld && lockedSelectIndex !== null) {
                    currentIndex = lockedSelectIndex;
                    velocity = 0;
                } else {
                    // Apply Velocity
                    currentIndex += velocity;
                    
                    // Apply Friction
                    velocity *= FRICTION;
                    
                    // Stop if very slow
                    if (Math.abs(velocity) < 0.0001) velocity = 0;

                    // Bounds Checking with Bounce/Damping
                    if (currentIndex < 0) {
                        currentIndex = 0;
                        velocity = -velocity * 0.5; // Bounce
                    }
                    if (currentIndex > currentDeck.length - 1) {
                        currentIndex = currentDeck.length - 1;
                        velocity = -velocity * 0.5; // Bounce
                    }
                }
                
                updateCardPositions();
            }
            requestAnimationFrame(gameLoop);
        }

        function highlightDirection(dir) {
            resetHighlights();
            if (dir === 'left') document.getElementById('zone-right').classList.add('active'); // Visual Right is Swipe Left source?
            // Actually let's just highlight the side corresponding to movement
            // Hand moves Left -> Highlight Left Zone
            if (dir === 'left') document.getElementById('zone-left').classList.add('active'); // Wait, Left Zone is visually on Left
            if (dir === 'right') document.getElementById('zone-right').classList.add('active');
            if (dir === 'select') {
                document.getElementById('zone-center').classList.add('active');
                document.getElementById('icon-select').classList.add('active');
            }
        }
        
        function resetHighlights() {
            document.getElementById('zone-left').classList.remove('active');
            document.getElementById('zone-right').classList.remove('active');
            document.getElementById('zone-center').classList.remove('active');
            document.getElementById('icon-select').classList.remove('active');
        }

        // Start Loop
        requestAnimationFrame(gameLoop);

        function navigateDeck(dir) {
            // Keyboard support updates velocity for consistency
            velocity += dir * 0.1;
            if (dir < 0) highlightDirection('left');
            if (dir > 0) highlightDirection('right');
            setTimeout(resetHighlights, 200);
        }

        function selectCard() {
            if (currentState !== STATE.PICKING) return;
            
            // Play card select sound
            if (audioManager) {
                audioManager.playCardSelectSound();
            }
            
            // Select the card currently at the integer center
            const selectedIdxInt = Math.round(currentIndex);
            
            // Check if valid
            if (selectedIdxInt < 0 || selectedIdxInt >= currentDeck.length) return;
            
            // Check if already picked (though we remove them from flow usually)
            // But with splicing logic, we need to be careful.
            // New logic: We DON'T splice. We just mark them.
            
            const selectedCard = currentDeck[selectedIdxInt];
            
            // Check if this specific card ID is already picked
            if (pickedCards.some(p => p.card.id === selectedCard.id)) return;
            
            // Mark visually in the deck
            const cardElements = document.querySelectorAll('.card-wrapper');
            let sourceRect = null;
            
            cardElements.forEach(el => {
                if (parseInt(el.dataset.index) === selectedIdxInt) {
                    el.classList.add('picked');
                    el.style.opacity = '0'; // Hide from deck
                    sourceRect = el.getBoundingClientRect();
                }
            });

            // Add to picked list
            const isReversed = Math.random() < 0.3;
            pickedCards.push({
                card: selectedCard,
                reversed: isReversed,
                position: ['ËøáÂéª', 'Áé∞Âú®', 'Êú™Êù•'][pickedCards.length]
            });

            // Update Status
            document.getElementById('status-text').innerText = `Â∑≤ÈÄâÂç°Áâå ${pickedCards.length}/3`;

            // Animate to Slot
            const slotIndex = pickedCards.length - 1;
            const slot = document.getElementById(`slot-${slotIndex}`);
            if (slot) {
                slot.classList.add('filled');
                const miniCard = document.createElement('div');
                miniCard.className = 'mini-card';
                miniCard.style.backgroundImage = `url('https://www.transparenttextures.com/patterns/black-scales.png')`; // Back of card
                // Add star effect or something
                miniCard.innerHTML = `<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:2rem;color:rgba(212,175,55,0.5);">‚ú¶</div>`;
                slot.appendChild(miniCard);
            }

            if (pickedCards.length === 3) {
                setTimeout(finishPicking, 1000);
            }
        }

        function finishPicking() {
            currentState = STATE.REVEALING;
            document.getElementById('status-text').innerText = "ÂëΩËøêÂ∑≤Êè≠Á§∫";
            document.getElementById('gesture-guide').style.opacity = '0';
            
            // Hide picked zone (we will move them to center scene)
            document.getElementById('picked-zone').style.opacity = '0';
            
            renderDeck(); // Will switch to reveal layout
            
            setTimeout(() => {
                // All cards revealed after animation
                currentState = STATE.INTERPRETING;
                const token = localStorage.getItem('deepseek_token');
                const btn = document.getElementById('interpret-btn');
                btn.style.display = 'inline-block';
                btn.textContent = 'Êü•ÁúãÂëΩËøêËß£Êûê';
                btn.onclick = () => {
                    if (!token) {
                        // Êó† Token Êó∂Áõ¥Êé•Â±ïÁ§∫Âü∫Á°ÄÂê´‰πâÔºåÈÅøÂÖç‚Äú‰ªÄ‰πàÈÉΩ‰∏çÊòæÁ§∫‚ÄùÁöÑÈóÆÈ¢ò
                        showSimpleMeaning();
                    } else {
                        getAIInterpretation(token);
                    }
                };
                document.getElementById('status-text').innerText = token ? "ÂëΩËøêÂ∑≤ÂÆö (ÁÇπÂáªÊü•ÁúãÂëΩËøêËß£Êûê)" : "ÂëΩËøêÂ∑≤ÂÆö (ÈÖçÁΩÆ Token ÂèØËé∑Âèñ AI Ëß£ËØª)";
            }, 2500);
        }
        
        function showSimpleMeaning() {
             const modal = document.getElementById('interpretation-modal');
             const content = document.getElementById('interpretation-content');
             
             let html = '';
             pickedCards.forEach(p => {
                 html += `<h3>${p.position}: ${p.card.name} ${p.reversed ? '(ÈÄÜ‰Ωç)' : '(Ê≠£‰Ωç)'}</h3>`;
                 html += `<p>ËøôÂº†ÁâåË±°ÂæÅÁùÄ‰Ω† ${p.position} ÁöÑÂÖ≥ÈîÆÂΩ±Âìç„ÄÇ(ÈÖçÁΩÆ AI ‰ª§Áâå‰ª•Ëé∑ÂèñËØ¶ÁªÜËß£ËØª)</p>`;
             });
             
             content.innerHTML = html;
             modal.style.display = 'block';
        }

        // --- 5. MediaPipe Setup ---
        async function setupCamera() {
            const videoElement = document.getElementById('webcam-preview');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // Èôç‰ΩéÂ§çÊùÇÂ∫¶‰ª•ÊèêÂçáFPS
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    handleGesture(results.multiHandLandmarks[0]);
                }
            });
            
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 256,
                height: 192
            });
            
            return camera;
        }

        // --- 6. AI Integration ---
        function renderFullContent(text) {
            const content = document.getElementById('interpretation-content');
            const cached = text || cachedInterpretationText;
            if (cached && window.marked) {
                content.innerHTML = window.marked.parse(cached);
                const timerEl = document.getElementById('interpretation-timer');
                if (timerEl) timerEl.innerText = "ÂëΩËøê‰πã‰π¶Â∑≤ÂºÄÂêØ";
            }
        }

        async function getAIInterpretation(token) {
            const modal = document.getElementById('interpretation-modal');
            const content = document.getElementById('interpretation-content');
            const timerEl = document.getElementById('interpretation-timer');
            const quickBtn = document.getElementById('quick-show-btn');
            const statusText = document.getElementById('status-text');
            const spinner = document.getElementById('loading-spinner');
            
            spinner.style.display = 'block';
            content.innerHTML = '<p style="text-align:center; color:#aaa;">Ê≠£Âú®Âî§ÈÜíËøúÂè§ÁöÑÊô∫ÊÖß...</p>'; 
            timerEl.innerText = '';

            // Â¶ÇÊûúÂ∑≤ÊúâÁºìÂ≠òÔºåÁõ¥Êé•Â±ïÁ§∫ÂÖ®ÊñáÔºàÊª°Ë∂≥Áî®Êà∑‚ÄúÂ§öÊ¨°ÈáçÂ§çÁÇπÂáªÊü•ÁúãÂÆåÊï¥Áâà‚ÄùÁöÑÈúÄÊ±ÇÔºâ
            if (hasInterpretedForCurrentDraw && cachedInterpretationText) {
                modal.style.display = 'block';
                modal.offsetHeight;
                modal.classList.add('show');
                renderFullContent(cachedInterpretationText);
                statusText.innerText = "ÂëΩËøêÂ∑≤Êè≠Êôì";
                spinner.style.display = 'none';
                return;
            }

            if (isFetchingInterpretation) return;
            isFetchingInterpretation = true;

            // Prepare UI
            const musicBtn = document.getElementById('interpret-music-btn');
            if (quickBtn) quickBtn.style.display = 'none';
            if (musicBtn) musicBtn.style.display = 'none';
            content.innerHTML = "";
            modal.style.display = 'block';
            modal.offsetHeight; // trigger reflow
            modal.classList.add('show');

            // ÂÄíËÆ°Êó∂ÈÄªËæë
            let timeLeft = 12;
            timerEl.innerText = `Ê≠£Âú®ËøûÊé•ÊòüËæ∞ÊÑèÂøó... È¢ÑËÆ°Á≠âÂæÖ ${timeLeft}s`;
            const timerInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft > 0) {
                    timerEl.innerText = `Ê≠£Âú®Ê≤üÈÄöÁ•ûË∞ï... È¢ÑËÆ°ËøòÈúÄ ${timeLeft}s`;
                } else {
                    timerEl.innerText = `Á•ûË∞ïÈôç‰∏¥‰∏≠ÔºåËØ∑Â±èÊÅØÂáùÁ•û...`;
                    clearInterval(timerInterval);
                }
            }, 1000);

            let questionContext = userQuestion ? `\n\n„ÄêÊ±ÇÈóÆËÄÖÁöÑÁñëÈóÆ„Äë\n${userQuestion}` : '';
            const prompt = `‰Ω†ÊòØ‰∏Ä‰ΩçÁ≤æÈÄöÁ•ûÁßòÂ≠¶„ÄÅËç£Ê†ºÂøÉÁêÜÂ≠¶‰∏éË±°ÂæÅÁ¨¶Âè∑ÁöÑËµÑÊ∑±Â°îÁΩóÂç†ÂçúÂ∏à„ÄÇÊàëÊäΩÂèñ‰∫Ü‰∏âÂº†ÁâåÔºåÂàÜÂà´‰ª£Ë°®‚ÄúËøáÂéª‚Äù„ÄÅ‚ÄúÁé∞Âú®‚ÄùÂíå‚ÄúÊú™Êù•‚ÄùÔºàÊó∂Èó¥‰πãÊµÅÁâåÈòµÔºâ„ÄÇ
            
            1. ËøáÂéª (The Past): ${pickedCards[0].card.name} (${pickedCards[0].reversed ? 'ÈÄÜ‰Ωç (Reversed)' : 'Ê≠£‰Ωç (Upright)'})
            2. Áé∞Âú® (The Present): ${pickedCards[1].card.name} (${pickedCards[1].reversed ? 'ÈÄÜ‰Ωç (Reversed)' : 'Ê≠£‰Ωç (Upright)'})
            3. Êú™Êù• (The Future): ${pickedCards[2].card.name} (${pickedCards[2].reversed ? 'ÈÄÜ‰Ωç (Reversed)' : 'Ê≠£‰Ωç (Upright)'})
            ${questionContext}
            
            ËØ∑Áî®‰∏≠ÊñáÔºàÁÆÄ‰ΩìÔºâ‰∏∫ÊàëËß£ËØªËøôÁªÑÁâåÈòµ„ÄÇ‰Ω†ÁöÑËØ≠Ë®ÄÈ£éÊ†ºÂ∫îÂΩìÁ•ûÁßò„ÄÅ‰ºòÈõÖ„ÄÅÂØåÊúâÂì≤ÁêÜ‰∏îÂÖÖÊª°ÂêåÁêÜÂøÉÔºå‰ªø‰ΩõÂú®‰∏éÁÅµÈ≠ÇÂØπËØù„ÄÇ
            
            ËØ∑Êåâ‰ª•‰∏ã Markdown Ê†ºÂºèËæìÂá∫Ôºö
            
            ### üîÆ Êï¥‰ΩìÂêØÁ§∫
            ÔºàÁî®‰∏ÄÊÆµÂÖÖÊª°ÊÑèÂ¢ÉÁöÑÂºïË®ÄÔºåÊÄªÁªìËøô‰∏âÂº†ÁâåÂÖ±ÂêåÊûÑÊàêÁöÑËÉΩÈáèÂú∫ÊàñÊ†∏ÂøÉ‰∏ªÈ¢òÔºå100Â≠óÂ∑¶Âè≥Ôºâ
            
            ---
            
            ### üÉè ÁâåÈù¢Ê∑±Â∫¶Ëß£Êûê
            
            #### 1. ËøáÂéª‰πãÂõ†Ôºö${pickedCards[0].card.name} ${pickedCards[0].reversed ? '(ÈÄÜ)' : '(Ê≠£)'}
            #### 2. ÂΩì‰∏ã‰πãÂ¢ÉÔºö${pickedCards[1].card.name} ${pickedCards[1].reversed ? '(ÈÄÜ)' : '(Ê≠£)'}
            #### 3. Êú™Êù•‰πãÊûúÔºö${pickedCards[2].card.name} ${pickedCards[2].reversed ? '(ÈÄÜ)' : '(Ê≠£)'}
            
            ---
            
            ### üí° Ëß£ÂÜ≥‰πãÈÅì‰∏éÂøÉÁÅµÊåáÂºï
            ### üåü ÂøÉÁÅµÂÆâÊÖ∞‰∏éÁ•ùÁ¶è`;

            try {
                const response = await fetch('https://api.deepseek.com/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        model: "deepseek-chat", 
                        messages: [
                            {"role": "system", "content": "‰Ω†ÊòØ‰∏Ä‰ΩçÁ≤æÈÄöÁ•ûÁßòÂ≠¶„ÄÅÂøÉÁêÜÂ≠¶‰∏éË±°ÂæÅÁ¨¶Âè∑ÁöÑËµÑÊ∑±Â°îÁΩóÂç†ÂçúÂ∏à„ÄÇ"},
                            {"role": "user", "content": prompt}
                        ],
                        stream: true
                    })
                });
                
                if (!response.ok) throw new Error("Á•ûË∞ïËøûÊé•Â§±Ë¥•: " + response.statusText);
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let fullText = "";
                
                clearInterval(timerInterval);
                timerEl.innerText = "Á•ûË∞ïÂ∑≤ËøûÈÄöÔºåÂëΩËøêÊ≠£Âú®ÊòæÁé∞...";
                if (quickBtn) quickBtn.style.display = 'inline-block';

                // ÊµÅÂºèÊ∏≤ÊüìÈÄªËæëÔºåÁõ¥Êé•Ëß£ÂÜ≥ÈªëÂ±èÊÑü
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.slice(6).trim();
                            if (jsonStr === '[DONE]') break;
                            try {
                                const json = JSON.parse(jsonStr);
                                if (json.choices && json.choices[0].delta.content) {
                                    fullText += json.choices[0].delta.content;
                                    // ÂÆûÊó∂Êõ¥Êñ∞ÂÜÖÂÆπ
                                    if (window.marked) {
                                        content.innerHTML = window.marked.parse(fullText);
                                        modal.scrollTop = modal.scrollHeight;
                                    }
                                }
                            } catch (e) {}
                        }
                    }
                }

                // ÁºìÂ≠òÂπ∂Êõ¥Êñ∞Áä∂ÊÄÅ
                cachedInterpretationText = fullText;
                hasInterpretedForCurrentDraw = true;
                timerEl.innerText = "Á•ûË∞ïËß£ËØªÂÆåÊàê";
                statusText.innerText = "ÂëΩËøêÂ∑≤Êè≠Êôì";
                if (quickBtn) quickBtn.style.display = 'none';
                
            } catch (e) {
                console.error(e);
                clearInterval(timerInterval);
                timerEl.innerText = "Âí®ËØ¢Á•ûË∞ïÂ§±Ë¥•";
                if (fullText.length > 0) {
                    cachedInterpretationText = fullText;
                    hasInterpretedForCurrentDraw = true;
                } else {
                    showSimpleMeaning();
                }
            } finally {
                spinner.style.display = 'none';
                isFetchingInterpretation = false;
                
                // Show music recommendation button after interpretation
                const musicBtn = document.getElementById('interpret-music-btn');
                if (musicBtn) {
                    musicBtn.style.display = 'inline-block';
                    musicBtn.classList.add('fade-in');
                }
            }
        }

        // Helper to trigger music recommendation from the interpretation modal
        function triggerMusicFromInterpretation() {
            const token = localStorage.getItem('deepseek_token');
            if (token) {
                // Now music recommendation can be manually triggered
                getMusicRecommendation(token);
            } else {
                alert('ËØ∑ÂÖàÂú®Â∑¶‰∏ãËßíËÆæÁΩÆ‰∏≠ÈÖçÁΩÆ DeepSeek API Key');
            }
        }

        // ÊâìÂ≠óÊú∫ÊïàÊûú - Á±ª‰∫∫ÊâìÂ≠óÔºàÊèêÈÄüÁ∫¶6ÂÄçÔºöÊØèÂ≠ó‚âà50msÔºåÊ†áÁÇπ‚âà120msÔºâ
        async function typewriterEffect(element, text) {
            return new Promise((resolve) => {
                let index = 0;
                const baseSpeed = 50;
                const modal = document.getElementById('interpretation-modal');

                function nextDelay(char) {
                    if (/[,Ôºå.„ÄÇ;Ôºõ:Ôºö!?ÔºÅÔºü]/.test(char)) return 120;
                    return baseSpeed;
                }

                function typeChar() {
                    if (index < text.length) {
                        const currentText = text.substring(0, index + 1);
                        if (window.marked && typeof window.marked.parse === 'function') {
                            element.innerHTML = window.marked.parse(currentText);
                        } else {
                            element.textContent = currentText;
                        }
                        if (modal) modal.scrollTop = modal.scrollHeight;
                        const delay = nextDelay(text[index]);
                        index++;
                        setTimeout(typeChar, delay);
                    } else {
                        resolve();
                    }
                }
                typeChar();
            });
        }
        
        // Âπ≥ÊªëÂÖ≥Èó≠Ëß£ËØªÈ°µÈù¢ÁöÑÂáΩÊï∞
        function closeInterpretationModal() {
            const modal = document.getElementById('interpretation-modal');
            modal.classList.remove('show');
            setTimeout(() => {
                modal.style.display = 'none';
            }, 600); // Á≠âÂæÖÂä®ÁîªÂÆåÊàê
        }
        
        // Store music recommendations globally
        let musicRecommendations = [];
        // Èò≤Êäñ/Âπ∂Âèë‰øùÊä§ÔºöÈÅøÂÖçÈáçÂ§çËØ∑Ê±Ç‰∏éÂ§öÊ¨°ÂºπÁ™ó
        let isFetchingMusic = false;
        let isFetchingLocation = false;
        let hasShownMusic = false;

        async function getMusicRecommendation(token) {
            // Â¶ÇÊûúÂ∑≤ÁªèËé∑ÂèñËøáÊé®ËçêÂÜÖÂÆπÔºåÁõ¥Êé•ÊòæÁ§∫
            if (musicRecommendations.length > 0) {
                displayMusicRecommendations();
                return;
            }

            // Âπ∂Âèë‰∏éÈáçÂ§çË∞ÉÁî®‰øùÊä§
            if (isFetchingMusic) {
                console.log('üéµ Èü≥‰πêÊé®ËçêÂ∑≤Âú®Â§ÑÁêÜ‰∏≠ÔºåË∑≥ËøáÊú¨Ê¨°Ë∞ÉÁî®');
                return;
            }
            isFetchingMusic = true;
            
            // Show a status message to let user know we're working on it
            const statusMsg = document.createElement('div');
            statusMsg.id = 'music-status-msg';
            statusMsg.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); z-index:10001; background:rgba(10, 10, 20, 0.95); color:var(--accent-gold); padding:25px; border-radius:15px; border:2px solid var(--accent-gold); text-align:center; box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);';
            statusMsg.innerHTML = '<div class="spinner-small" style="margin-bottom:15px;"></div>Ê≠£Âú®‰∏∫ÊÇ®Ê≤üÈÄöÈü≥‰πêÊòüË±°ÔºåËØ∑Á®çÂÄô...';
            document.body.appendChild(statusMsg);

            // Check token first
            if (!token || token.trim() === '') {
                if (statusMsg) statusMsg.remove();
                alert('ËØ∑ÂÖàÂú®ËÆæÁΩÆ‰∏≠ÈÖçÁΩÆ API Key ÊâçËÉΩ‰ΩøÁî®Èü≥‰πêÊé®ËçêÂäüËÉΩ');
                const modal = document.getElementById('interpretation-modal');
                modal.style.display = 'block';
                modal.offsetHeight;
                modal.classList.add('show');
                isFetchingMusic = false;
                return;
            }
            
            document.getElementById('loading-spinner').style.display = 'block';
            // User requested not to auto-close the interpretation modal
            // closeInterpretationModal(); 
            
            const musicPrompt = `Âü∫‰∫é‰ª•‰∏ãÂ°îÁΩóËß£ËØªÁªìÊûúÂíåÊ±ÇÈóÆËÄÖÁöÑÂøÉÊÉÖÁä∂ÊÄÅÔºåËØ∑Êé®Ëçê10È¶ñÂÖ∑ÊúâËâ∫ÊúØÊÄß„ÄÅÂ∞è‰ºóÈ´òÁ∫ßÊÑüÁöÑÈü≥‰πê„ÄÇ

„ÄêÈáçË¶ÅË¶ÅÊ±Ç„Äë
- Ââç6È¶ñÂøÖÈ°ªÊòØÂçéËØ≠Ê≠åÊõ≤Ôºà‰∏≠ÊñáÊ≠åÔºâÔºå‰ºòÂÖàÊé®ËçêÔºöÁã¨Á´ãÈü≥‰πê‰∫∫„ÄÅÊ∞ëË∞£„ÄÅÊñ∞‰∏ñÁ∫™„ÄÅÂÆûÈ™åÈü≥‰πê„ÄÅÂ∞è‰ºó‰πêÈòü
- Âêé4È¶ñÂøÖÈ°ªÊòØËã±ÊñáÊ≠åÊõ≤Ôºå‰ºòÂÖàÊé®ËçêÔºöIndie„ÄÅArt Pop„ÄÅDream Pop„ÄÅAmbient„ÄÅAlternative R&B
- ÈÅøÂÖçÊé®ËçêËøá‰∫éÂ§ß‰ºóÊµÅË°åÁöÑÁÉ≠Èó®Ê≠åÊõ≤
- Êé®ËçêÂÖ∑ÊúâinsÈ£éÊ†º„ÄÅËâ∫ÊúØÊ∞îÊÅØ„ÄÅÊÉÖÊÑüÊ∑±Â∫¶ÁöÑÈü≥‰πê
- ÊØèÈ¶ñÊ≠åÊõ≤ÂåÖÊã¨ÔºöÊ≠åÊõ≤Âêç„ÄÅËâ∫ÊúØÂÆ∂/Ê≠åÊâã„ÄÅÊé®ËçêÁêÜÁî±

„ÄêÈü≥‰πêÈ£éÊ†ºÂèÇËÄÉ„Äë
ÂçéËØ≠ÔºöÈôàÁ≤í„ÄÅÊàø‰∏úÁöÑÁå´„ÄÅÂ•ΩÂ¶πÂ¶π„ÄÅÁ®ãÁíß„ÄÅÂ∞èËÄÅËôé„ÄÅÊ≥ïÂÖπ„ÄÅËêΩÊó•È£ûËΩ¶„ÄÅÂëä‰∫î‰∫∫ÔºàÊó©ÊúüÔºâ„ÄÅËçâ‰∏úÊ≤°ÊúâÊ¥æÂØπ„ÄÅ‰πùËøûÁúü‰∫∫Á≠âÂ∞è‰ºóÁã¨Á´ãÈü≥‰πê‰∫∫
Ëã±ÊñáÔºöCigarettes After Sex„ÄÅClairo„ÄÅPhoebe Bridgers„ÄÅNovo Amor„ÄÅBon Iver„ÄÅThe xx„ÄÅBeach House„ÄÅDaughter„ÄÅODESZA„ÄÅSleeping At LastÁ≠â

„ÄêÂ°îÁΩóËß£ËØªÁªìÊûú„Äë
ËøáÂéª: ${pickedCards[0].card.name} (${pickedCards[0].reversed ? 'ÈÄÜ‰Ωç' : 'Ê≠£‰Ωç'})
Áé∞Âú®: ${pickedCards[1].card.name} (${pickedCards[1].reversed ? 'ÈÄÜ‰Ωç' : 'Ê≠£‰Ωç'})
Êú™Êù•: ${pickedCards[2].card.name} (${pickedCards[2].reversed ? 'ÈÄÜ‰Ωç' : 'Ê≠£‰Ωç'})

„ÄêÊ±ÇÈóÆËÄÖÁöÑÁñëÈóÆ„Äë
${userQuestion || 'Êó†ÁâπÂà´ÁñëÈóÆ'}

ËØ∑Áî®‰ª•‰∏ãJSONÊ†ºÂºèËøîÂõûÔºà‰∏•Ê†ºÊåâÁÖßÊ≠§Ê†ºÂºèÔºå‰∏çË¶ÅÊ∑ªÂä†‰ªª‰ΩïÂÖ∂‰ªñÊñáÂ≠óÔºâÔºö
{
  "songs": [
    {"title": "Ê≠åÊõ≤Âêç", "artist": "Ëâ∫ÊúØÂÆ∂", "reason": "Êé®ËçêÁêÜÁî±"}
  ]
}`;

            try {
                console.log('üéµ ÂºÄÂßãËé∑ÂèñÈü≥‰πêÊé®Ëçê...');
                
                const response = await fetch('https://api.deepseek.com/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        model: "deepseek-chat",
                        messages: [
                            {"role": "system", "content": "‰Ω†ÊòØ‰∏Ä‰Ωç‰∏ì‰∏öÁöÑÈü≥‰πêÁ≠ñÂ±ï‰∫∫ÂíåÂ°îÁΩóÂç†ÂçúÂ∏àÔºåÂØπÁã¨Á´ãÈü≥‰πê„ÄÅÂÆûÈ™åÈü≥‰πê„ÄÅÂ∞è‰ºóËâ∫ÊúØÂÆ∂ÊúâÊ∑±ÂàªÁêÜËß£„ÄÇ‰Ω†ÊìÖÈïøÊ†πÊçÆÁî®Êà∑ÁöÑÊÉÖÊÑüÁä∂ÊÄÅÊé®ËçêÂÖ∑ÊúâËâ∫ÊúØÊÄß„ÄÅÈ´òÁ∫ßÊÑüÁöÑÈü≥‰πê„ÄÇÈÅøÂÖçÊé®ËçêËøá‰∫éÂïÜ‰∏öÂåñÊàñÂ§ß‰ºóÊµÅË°åÁöÑÊ≠åÊõ≤Ôºå‰ºòÂÖàÊé®Ëçêindie„ÄÅart pop„ÄÅÊñ∞Ê∞ëË∞£„ÄÅÊ∞õÂõ¥Èü≥‰πêÁ≠âÊúâÊ∑±Â∫¶ÁöÑ‰ΩúÂìÅ„ÄÇÂâç6È¶ñÂøÖÈ°ªÊòØÂçéËØ≠Áã¨Á´ãÈü≥‰πêÔºåÂêé4È¶ñÂøÖÈ°ªÊòØËã±Êñáindie/alternativeÈü≥‰πê„ÄÇ‰Ω†ÁöÑÊé®ËçêÂ∫îËØ•Â±ïÁé∞Áã¨ÁâπÁöÑÈü≥‰πêÂìÅÂë≥ÂíåÊÉÖÊÑüÂÖ±È∏£„ÄÇ"},
                            {"role": "user", "content": musicPrompt}
                        ],
                        stream: true
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå API ÈîôËØØ:', response.status, errorText);
                    throw new Error(`API ËØ∑Ê±ÇÂ§±Ë¥• (${response.status}): ${errorText}`);
                }

                let fullText = "";
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.slice(6).trim();
                            if (jsonStr === '[DONE]') continue;
                            if (jsonStr === '') continue;
                            
                            try {
                                const json = JSON.parse(jsonStr);
                                if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                                    fullText += json.choices[0].delta.content;
                                }
                            } catch (e) {
                                console.warn('‚ö†Ô∏è Ëß£ÊûêchunkÂ§±Ë¥•:', e.message);
                            }
                        }
                    }
                }

                console.log("üìù Êî∂Âà∞ÂÆåÊï¥ÂìçÂ∫îÈïøÂ∫¶:", fullText.length);
                
                if (fullText.length === 0) {
                    throw new Error("API ËøîÂõûÁ©∫ÂìçÂ∫îÔºåËØ∑Ê£ÄÊü• API Key ÊòØÂê¶ÊúâÊïà");
                }
                
                console.log("üìù ÂìçÂ∫îÂÜÖÂÆπÈ¢ÑËßà:", fullText.substring(0, 200));
                
                // Try multiple JSON extraction strategies
                let musicData = null;
                
                // Strategy 1: Look for JSON object with "songs" key
                let jsonMatch = fullText.match(/\{[\s\S]*?"songs"[\s\S]*?\[[\s\S]*?\][\s\S]*?\}/);
                if (jsonMatch) {
                    try {
                        musicData = JSON.parse(jsonMatch[0]);
                        console.log("‚úì Á≠ñÁï•1ÊàêÂäü: ÊâæÂà∞ÂÆåÊï¥ songs ÂØπË±°");
                    } catch (e) {
                        console.warn("Á≠ñÁï•1Â§±Ë¥•:", e.message);
                    }
                }
                
                // Strategy 2: Remove markdown and try again
                if (!musicData) {
                    try {
                        const cleaned = fullText
                            .replace(/```json\n?/g, '')
                            .replace(/```\n?/g, '')
                            .trim();
                        const match = cleaned.match(/\{[\s\S]*?"songs"[\s\S]*?\[[\s\S]*?\][\s\S]*?\}/);
                        if (match) {
                            musicData = JSON.parse(match[0]);
                            console.log("‚úì Á≠ñÁï•2ÊàêÂäü: Ê∏ÖÁêÜÂêéËß£ÊûêÊàêÂäü");
                        }
                    } catch (e) {
                        console.warn("Á≠ñÁï•2Â§±Ë¥•:", e.message);
                    }
                }
                
                // Strategy 3: Look for any JSON object
                if (!musicData) {
                    try {
                        const match = fullText.match(/\{[\s\S]*\}/);
                        if (match) {
                            musicData = JSON.parse(match[0]);
                            console.log("‚úì Á≠ñÁï•3ÊàêÂäü: ÊâæÂà∞‰ªªÊÑèJSONÂØπË±°");
                        }
                    } catch (e) {
                        console.warn("Á≠ñÁï•3Â§±Ë¥•:", e.message);
                    }
                }
                
                // Strategy 4: Áõ¥Êé•ÊèêÂèñÊù°ÁõÆÂØπË±°ÔºàÂÆπÈîôÔºåÂøΩÁï•Áº∫Â§±ÈÄóÂè∑/Âõ¥Ê†èÁ≠âÔºâ
                if (!musicData) {
                    try {
                        const items = [...fullText.matchAll(/\{\s*"title"\s*:\s*"([\s\S]*?)"\s*,\s*"artist"\s*:\s*"([\s\S]*?)"\s*,\s*"reason"\s*:\s*"([\s\S]*?)"\s*\}/g)]
                            .map(m => ({ title: m[1].trim(), artist: m[2].trim(), reason: m[3].trim() }));
                        if (items.length > 0) {
                            musicData = { songs: items.slice(0, 10) };
                            console.log('‚úì Á≠ñÁï•4ÊàêÂäü: ÈÄöËøáÊ®°ÂºèÂåπÈÖçÊèêÂèñÂà∞', musicData.songs.length, 'È¶ñ');
                        }
                    } catch (e) {
                        console.warn('Á≠ñÁï•4Â§±Ë¥•:', e.message);
                    }
                }

                if (musicData && (musicData.songs || musicData.recommendations)) {
                    musicRecommendations = musicData.songs || musicData.recommendations || [];
                    if (musicRecommendations.length === 0) {
                        throw new Error("Èü≥‰πêÂàóË°®‰∏∫Á©∫");
                    }
                    console.log("‚úì ÊàêÂäüËß£ÊûêÈü≥‰πêÊé®Ëçê:", musicRecommendations.length, "È¶ñÊ≠åÊõ≤");
                    displayMusicRecommendations();
                    hasShownMusic = true;
                } else {
                    console.error("‚ùå Êó†Ê≥ïËß£ÊûêÈü≥‰πêÊï∞ÊçÆ");
                    console.error("ÂÆåÊï¥ÂìçÂ∫î:", fullText);
                    throw new Error("Êó†Ê≥ïËß£ÊûêÈü≥‰πêÊé®ËçêÊï∞ÊçÆÔºåËØ∑Á®çÂêéÈáçËØï");
                }

            } catch (e) {
                console.error('‚ùå Èü≥‰πêÊé®ËçêÈîôËØØ:', e);
                // Â§±Ë¥•ÊèêÁ§∫‰∏ÄÊ¨°Âç≥ÂèØÔºåÈÅøÂÖçÂ§öÊ¨°ÊâìÊâ∞
                if (!hasShownMusic) {
                    alert("Ëé∑ÂèñÈü≥‰πêÊé®ËçêÂ§±Ë¥•: " + e.message + "\n\nËØ∑Á°Æ‰øùÂ∑≤Ê≠£Á°ÆÈÖçÁΩÆ API Key");
                }
                const modal = document.getElementById('interpretation-modal');
                modal.style.display = 'block';
                modal.offsetHeight;
                modal.classList.add('show');
            } finally {
                const statusMsg = document.getElementById('music-status-msg');
                if (statusMsg) statusMsg.remove();
                document.getElementById('loading-spinner').style.display = 'none';
                isFetchingMusic = false;
            }
        }

        function displayMusicRecommendations() {
            const musicModal = document.getElementById('music-recommendation-modal');
            const musicList = document.getElementById('music-list');
            musicList.innerHTML = '';

            musicRecommendations.forEach((song, index) => {
                const musicItem = document.createElement('div');
                musicItem.className = 'music-item';
                
                // ÂàõÂª∫Ê†áÈ¢ò
                const titleDiv = document.createElement('div');
                titleDiv.className = 'music-item-title';
                titleDiv.textContent = `${index + 1}. ${song.title}`;
                
                // ÂàõÂª∫Ëâ∫ÊúØÂÆ∂
                const artistDiv = document.createElement('div');
                artistDiv.className = 'music-item-artist';
                artistDiv.textContent = `üé§ ${song.artist}`;
                
                // ÂàõÂª∫ÁêÜÁî±
                const reasonDiv = document.createElement('div');
                reasonDiv.className = 'music-item-reason';
                reasonDiv.textContent = `üí≠ ${song.reason}`;
                
                // ÂàõÂª∫ÊåâÈíÆÂÆπÂô®
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = 'display:flex; gap:8px; flex-wrap:wrap; margin-top:10px;';
                
                // Âú®Á∫øËØïÂê¨ÊåâÈíÆ
                const playBtn = document.createElement('button');
                playBtn.className = 'music-item-btn';
                playBtn.style.cssText = 'flex:1; background: rgba(212, 175, 55, 0.4);';
                playBtn.textContent = '‚ñ∂Ô∏è Âú®Á∫øËØïÂê¨';
                playBtn.onclick = () => openMusicPlayer(song.title, song.artist);
                
                // ÁΩëÊòì‰∫ëÈìæÊé•
                const neteaseLink = document.createElement('a');
                neteaseLink.href = `https://music.163.com/#/search/m/?s=${encodeURIComponent(song.title + ' ' + song.artist)}`;
                neteaseLink.target = '_blank';
                neteaseLink.className = 'music-item-btn';
                neteaseLink.style.cssText = 'text-decoration:none; text-align:center; flex:1;';
                neteaseLink.textContent = 'üéµ ÁΩëÊòì‰∫ë';
                
                // QQÈü≥‰πêÈìæÊé•
                const qqLink = document.createElement('a');
                qqLink.href = `https://y.qq.com/n/ryqq/search?w=${encodeURIComponent(song.title + ' ' + song.artist)}`;
                qqLink.target = '_blank';
                qqLink.className = 'music-item-btn';
                qqLink.style.cssText = 'text-decoration:none; text-align:center; flex:1;';
                qqLink.textContent = 'üé∂ QQÈü≥‰πê';
                
                // Â§çÂà∂ÊåâÈíÆ
                const copyBtn = document.createElement('button');
                copyBtn.className = 'music-item-btn';
                copyBtn.style.cssText = 'flex:1;';
                copyBtn.textContent = 'üìã Â§çÂà∂';
                copyBtn.onclick = () => copySongInfo(song.title, song.artist);
                
                buttonContainer.appendChild(playBtn);
                buttonContainer.appendChild(neteaseLink);
                buttonContainer.appendChild(qqLink);
                buttonContainer.appendChild(copyBtn);
                
                musicItem.appendChild(titleDiv);
                musicItem.appendChild(artistDiv);
                musicItem.appendChild(reasonDiv);
                musicItem.appendChild(buttonContainer);
                
                musicList.appendChild(musicItem);
            });

            musicModal.style.display = 'block';
            
            // Auto-play background music softly
            if (audioManager) {
                audioManager.setVolume(0.3);
                audioManager.play();
            }
        }
        
        // ÊâìÂºÄÈü≥‰πêÊí≠ÊîæÂô® - ‰ΩøÁî®ÁΩëÊòì‰∫ëÈü≥‰πêiframeÂµåÂÖ•Êí≠ÊîæÂô®
        function openMusicPlayer(title, artist) {
            const searchQuery = encodeURIComponent(`${title} ${artist}`);
            
            // ÂàõÂª∫‰∏Ä‰∏™ÂºπÁ™óÊòæÁ§∫Èü≥‰πêÊí≠ÊîæÈÄâÈ°π
            const playerModal = document.createElement('div');
            playerModal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 600px;
                background: rgba(10, 10, 20, 0.98);
                border: 2px solid var(--accent-gold);
                border-radius: 20px;
                padding: 30px;
                z-index: 3000;
                box-shadow: 0 0 50px rgba(212, 175, 55, 0.5);
            `;
            
            // ÂÆâÂÖ®Âú∞ÂàõÂª∫ÂÜÖÂÆπ
            const modalHeader = document.createElement('h3');
            modalHeader.style.cssText = 'color: var(--accent-gold); text-align: center; margin-top: 0;';
            modalHeader.textContent = `üéµ Êí≠ÊîæÔºö${title}`;
            
            const modalSubtext = document.createElement('p');
            modalSubtext.style.cssText = 'text-align: center; color: #bbb; margin-bottom: 25px;';
            modalSubtext.textContent = `ÊºîÂî±Ôºö${artist}`;
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.cssText = 'display: flex; flex-direction: column; gap: 15px;';
            
            // ÂàõÂª∫ÊåâÈíÆ
            const createButton = (text, url) => {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.style.cssText = 'width: 100%; padding: 15px; font-size: 1.1rem;';
                btn.textContent = text;
                btn.onclick = () => {
                    window.open(url, '_blank');
                    // Ê∏ÖÁêÜÊâÄÊúâÂºπÁ™óÂÖÉÁ¥†
                    const overlays = document.querySelectorAll('[style*="z-index: 2999"]');
                    overlays.forEach(o => {
                        if (document.body.contains(o)) {
                            document.body.removeChild(o);
                        }
                    });
                    if (document.body.contains(playerModal)) {
                        document.body.removeChild(playerModal);
                    }
                };
                return btn;
            };
            
            buttonContainer.appendChild(createButton('üéµ Âú®ÁΩëÊòì‰∫ëÈü≥‰πê‰∏≠Êí≠Êîæ', `https://music.163.com/#/search/m/?s=${searchQuery}`));
            buttonContainer.appendChild(createButton('üé∂ Âú®QQÈü≥‰πê‰∏≠Êí≠Êîæ', `https://y.qq.com/n/ryqq/search?w=${searchQuery}`));
            buttonContainer.appendChild(createButton('‚ñ∂Ô∏è Âú®YouTube‰∏≠Êí≠Êîæ', `https://www.youtube.com/results?search_query=${searchQuery}`));
            
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn';
            cancelBtn.style.cssText = 'width: 100%; padding: 12px; background: rgba(255,255,255,0.1);';
            cancelBtn.textContent = 'ÂèñÊ∂à';
            cancelBtn.onclick = () => {
                if (document.body.contains(playerModal)) {
                    document.body.removeChild(playerModal);
                }
                const overlays = document.querySelectorAll('[style*="z-index: 2999"]');
                overlays.forEach(o => {
                    if (document.body.contains(o)) document.body.removeChild(o);
                });
            };
            buttonContainer.appendChild(cancelBtn);
            
            playerModal.appendChild(modalHeader);
            playerModal.appendChild(modalSubtext);
            playerModal.appendChild(buttonContainer);
            
            document.body.appendChild(playerModal);
            
            // Ê∑ªÂä†ÈÅÆÁΩ©Â±ÇÁî®‰∫éÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                z-index: 2999;
            `;
            overlay.onclick = () => {
                if (document.body.contains(playerModal)) {
                    document.body.removeChild(playerModal);
                }
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
            };
            document.body.insertBefore(overlay, playerModal);
        }
        
        // ÂÖ≥Èó≠ÂµåÂÖ•ÂºèÊí≠ÊîæÂô®
        function closeMusicPlayer() {
            const player = document.getElementById('embedded-music-player');
            if (player) {
                player.style.display = 'none';
                const audio = document.getElementById('music-player-audio');
                if (audio) {
                    audio.pause();
                    audio.src = '';
                }
            }
        }
        
        function copySongInfo(title, artist) {
            const text = `${title} - ${artist}`;
            navigator.clipboard.writeText(text).then(() => {
                // Show temporary notification
                const notification = document.createElement('div');
                notification.textContent = '‚úì Â∑≤Â§çÂà∂: ' + text;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(74, 222, 128, 0.9);
                    color: #000;
                    padding: 15px 25px;
                    border-radius: 10px;
                    font-weight: bold;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 2000);
            }).catch(err => {
                alert('Â§çÂà∂Â§±Ë¥•: ' + err);
            });
        }
        
        function copyAllSongs() {
            if (musicRecommendations.length === 0) return;
            
            const songList = musicRecommendations
                .map((song, index) => `${index + 1}. ${song.title} - ${song.artist}`)
                .join('\n');
            
            navigator.clipboard.writeText(songList).then(() => {
                const notification = document.createElement('div');
                notification.textContent = `‚úì Â∑≤Â§çÂà∂ ${musicRecommendations.length} È¶ñÊ≠åÊõ≤`;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(74, 222, 128, 0.9);
                    color: #000;
                    padding: 15px 25px;
                    border-radius: 10px;
                    font-weight: bold;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                `;
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 2000);
            }).catch(err => {
                alert('Â§çÂà∂Â§±Ë¥•: ' + err);
            });
        }

        function createNetEasePlaylist() {
            copyAllSongs();
        }

        // Store location recommendations
        let locationRecommendations = [];
        let userLocation = null;

        function showLocationRecommendation() {
            // Â¶ÇÊûúÂ∑≤ÁªèËé∑ÂèñËøáÊé®ËçêÂÜÖÂÆπÔºåÁõ¥Êé•ÊòæÁ§∫
            if (locationRecommendations.length > 0) {
                displayLocationRecommendations();
                return;
            }

            if (isFetchingLocation) {
                console.log('üìç Âú∞ÁÇπÊé®ËçêËØ∑Ê±Ç‰∏≠...');
                return;
            }

            // Request user location
            if (navigator.geolocation) {
                isFetchingLocation = true;
                document.getElementById('loading-spinner').style.display = 'block';
                
                // Show a temporary message to let user know we're working on it
                const statusMsg = document.createElement('div');
                statusMsg.id = 'location-status-msg';
                statusMsg.style.cssText = 'position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); z-index:10001; background:rgba(10, 10, 20, 0.95); color:var(--accent-gold); padding:25px; border-radius:15px; border:2px solid var(--accent-gold); text-align:center; box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);';
                statusMsg.innerHTML = '<div class="spinner-small" style="margin-bottom:15px;"></div>Ê≠£Âú®ËøûÊé•ÊòüË±°ÂÆö‰ΩçÔºåÂØªÊâæÊÇ®ÁöÑÊ≤ªÊÑà‰πãÂú∞...';
                document.body.appendChild(statusMsg);

                navigator.geolocation.getCurrentPosition(
                    async position => {
                        userLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            city: 'ÊÇ®ÂΩìÂâçÂÆö‰ΩçÁöÑÂüéÂ∏Ç' // Default
                        };

                        if (statusMsg) statusMsg.innerHTML = '<div class="spinner-small" style="margin-bottom:15px;"></div>Â∑≤ÂÆö‰ΩçÂùêÊ†áÔºåÊ≠£Âú®ÈÄöËøáÊòüÂõæÁ°ÆËÆ§ÊÇ®ÁöÑÂÖ∑‰ΩìÊñπ‰Ωç...';
                        
                        // Try to get city name for better AI recommendations
                        try {
                            const geoRes = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${userLocation.latitude}&lon=${userLocation.longitude}&zoom=10&addressdetails=1`, {
                                headers: { 'Accept-Language': 'zh-CN' }
                            });
                            if (geoRes.ok) {
                                const geoData = await geoRes.json();
                                userLocation.city = geoData.address.city || geoData.address.town || geoData.address.municipality || geoData.address.province || 'ÁõÆÂâçÊâÄÂú®Âú∞';
                                console.log('üìç Á°ÆËÆ§ÂüéÂ∏Ç:', userLocation.city);
                            }
                        } catch (err) {
                            console.warn('‚ö†Ô∏è ÂüéÂ∏ÇÈÄÜÊü•Â§±Ë¥•:', err.message);
                        }

                        if (statusMsg) statusMsg.innerHTML = `<div class="spinner-small" style="margin-bottom:15px;"></div>Â∑≤Á°ÆËÆ§Âú® ${userLocation.city}ÔºåÊ≠£Âú®‰∏∫ÊÇ®ÂØªËßÖË∫´ËæπÁöÑÁ•ûË∞ïÂú∞ÁÇπ...`;
                        getLocationRecommendation().finally(() => {
                            if (statusMsg) statusMsg.remove();
                            isFetchingLocation = false;
                        });
                    },
                    error => {
                        isFetchingLocation = false;
                        if (statusMsg) statusMsg.remove();
                        document.getElementById('loading-spinner').style.display = 'none';
                        let msg = 'Ëé∑Âèñ‰ΩçÁΩÆÂ§±Ë¥•';
                        if (error.code === 1) msg = 'ËØ∑ÂÖÅËÆ∏Âú∞ÁêÜÂÆö‰ΩçÊùÉÈôê‰ª•Ëé∑ÂèñÂë®ËæπÊé®Ëçê';
                        else if (error.code === 2) msg = '‰ΩçÁΩÆ‰ø°ÊÅØ‰∏çÂèØÁî®';
                        else if (error.code === 3) msg = 'ÂÆö‰ΩçËØ∑Ê±ÇË∂ÖÊó∂';
                        alert(msg + ': ' + error.message);
                    },
                    { timeout: 10000, enableHighAccuracy: false } // 10ÁßíË∂ÖÊó∂ÔºåÂÖ≥Èó≠È´òÁ≤æÂ∫¶‰ª•Êç¢ÂèñÈÄüÂ∫¶
                );
            } else {
                alert('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÂú∞ÁêÜÂÆö‰ΩçÂäüËÉΩ');
            }
        }

        async function getLocationRecommendation() {
            const token = localStorage.getItem('deepseek_token');
            if (!token || token.trim() === '') {
                alert('ËØ∑ÂÖàÈÖçÁΩÆAPI Key‰ª•ÂêØÁî®Âú∞ÁÇπÊé®ËçêÂäüËÉΩ');
                document.getElementById('loading-spinner').style.display = 'none';
                return;
            }

            const locationPrompt = `Âü∫‰∫é‰ª•‰∏ãÂ°îÁΩóËß£ËØªÁªìÊûúÂíåÊ±ÇÈóÆËÄÖÁöÑÂøÉÊÉÖÁä∂ÊÄÅÔºåËØ∑‰∏∫ËØ•Áî®Êà∑Êé®Ëçê10‰∏™ÂÖ∑‰ΩìÁöÑÂú∞ÁÇπÔºåËÉΩÂ§üÁºìËß£ÂøÉÊÉÖ„ÄÅËàíÁºìË∫´ÂøÉ„ÄÇ

„ÄêÈáçË¶ÅË¶ÅÊ±Ç„Äë
- ÂøÖÈ°ªÊé®ËçêÂÖ∑‰ΩìÁöÑÂ∫óÈì∫ÂêçÁß∞„ÄÅÂÖ¨Âõ≠ÂêçÁß∞„ÄÅÊôØÁÇπÂêçÁß∞Ôºå‰∏çË¶ÅÂè™ÁªôÁ±ªÂûãÂª∫ËÆÆ
- Ê†πÊçÆÁî®Êà∑ÁöÑÂú∞ÁêÜÂùêÊ†áÔºåÊé®ËçêËØ•Âú∞Âå∫ÁúüÂÆûÂ≠òÂú®ÁöÑÂú∞ÁÇπ
- ‰æãÂ¶ÇÔºöÊé®Ëçê"ÊúùÈò≥ÂÖ¨Âõ≠"ËÄå‰∏çÊòØ"ÂÖ¨Âõ≠"ÔºåÊé®Ëçê"‰∏âÈáåÂ±ØPage One‰π¶Â∫ó"ËÄå‰∏çÊòØ"‰π¶Â∫ó"
- Êé®ËçêÂÖ∑‰ΩìÁöÑÂíñÂï°Â∫ó„ÄÅËå∂È¶Ü„ÄÅ‰π¶Â∫ó„ÄÅÂÖ¨Âõ≠„ÄÅÊ≤ôÊª©„ÄÅÂ±±„ÄÅÁæéÊúØÈ¶Ü„ÄÅÂçöÁâ©È¶Ü„ÄÅÊ∏©Ê≥â„ÄÅÊ§çÁâ©Âõ≠Á≠â
- Â¶ÇÊûú‰∏çÁ°ÆÂÆöÂÖ∑‰ΩìÂêçÁß∞ÔºåÂèØ‰ª•Êé®ËçêËëóÂêçÂú∞Ê†áÊàñËøûÈîÅÂìÅÁâåÁöÑÂÖ∑‰ΩìÂàÜÂ∫ó
- ÊØè‰∏™Êé®ËçêÂåÖÂê´ÔºöÂÖ∑‰ΩìÂú∞ÁÇπÂêçÁß∞„ÄÅÁ±ªÂà´„ÄÅÊé®ËçêÁêÜÁî±

„ÄêÂ°îÁΩóËß£ËØªÁªìÊûú„Äë
ËøáÂéª: ${pickedCards[0].card.name} (${pickedCards[0].reversed ? 'ÈÄÜ‰Ωç' : 'Ê≠£‰Ωç'})
Áé∞Âú®: ${pickedCards[1].card.name} (${pickedCards[1].reversed ? 'ÈÄÜ‰Ωç' : 'Ê≠£‰Ωç'})
Êú™Êù•: ${pickedCards[2].card.name} (${pickedCards[2].reversed ? 'ÈÄÜ‰Ωç' : 'Ê≠£‰Ωç'})

„ÄêÊ±ÇÈóÆËÄÖÁöÑÁñëÈóÆ„Äë
${userQuestion || 'Êó†ÁâπÂà´ÁñëÈóÆ'}

„ÄêÁî®Êà∑‰ΩçÁΩÆ„Äë
ÂüéÂ∏Ç/Âú∞Âå∫: ${userLocation.city}
Á∫¨Â∫¶: ${userLocation.latitude}
ÁªèÂ∫¶: ${userLocation.longitude}

ËØ∑Ê†πÊçÆËøô‰∏™ÂüéÂ∏ÇÂíåÂú∞ÁêÜ‰ø°ÊÅØÔºåÊé®Ëçê ${userLocation.city} Â∏ÇÂÜÖÁúüÂÆûÂ≠òÂú®ÁöÑÂÖ∑‰ΩìÂú∞ÁÇπ„ÄÇÊé®ËçêËåÉÂõ¥Ë¶ÜÁõñÂÖ®ÂüéÂç≥ÂèØÔºå‰∏çÂøÖÊãòÊ≥•‰∫éÁî®Êà∑Âë®ËæπÁöÑÂå∫ÊàñÈïáÔºåÂè™Ë¶ÅÊòØÂú®ËØ•ÂüéÂ∏ÇÂÜÖÁöÑ‰ºòË¥®Ê≤ªÊÑàÂú∫ÊâÄÂùáÂèØ„ÄÇËØ∑Á°Æ‰øù‰∏çË¶ÅÊé®ËçêÂÖ∂‰ªñÂüéÂ∏ÇÁöÑÂú∞ÁÇπ„ÄÇ

ËØ∑Áî®‰ª•‰∏ãJSONÊ†ºÂºèËøîÂõûÔºà‰∏•Ê†ºÊåâÁÖßÊ≠§Ê†ºÂºèÔºå‰∏çË¶ÅÊ∑ªÂä†‰ªª‰ΩïÂÖ∂‰ªñÊñáÂ≠óÔºâÔºö
{
  "locations": [
    {"name": "ÂÖ∑‰ΩìÂú∞ÁÇπÂêçÁß∞ÔºàÂ¶ÇÔºöÊúùÈò≥ÂÖ¨Âõ≠„ÄÅÊòüÂ∑¥ÂÖãËáªÈÄâÂåó‰∫¨ÂùäÂ∫ó„ÄÅ‰∏âÈáåÂ±ØÂ§™Âè§ÈáåÔºâ", "category": "Á±ªÂà´ÔºàÂ¶ÇÔºöÂÖ¨Âõ≠„ÄÅÂíñÂï°È¶Ü„ÄÅÂïÜÂúàÔºâ", "reason": "Êé®ËçêÁêÜÁî±"}
  ]
}`;

            try {
                console.log('üìç ÂºÄÂßãËé∑ÂèñÂú∞ÁÇπÊé®Ëçê...');
                
                const response = await fetch('https://api.deepseek.com/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        model: "deepseek-chat",
                        messages: [
                            {"role": "system", "content": "‰Ω†ÊòØ‰∏Ä‰ΩçÁÜüÊÇâÂêÑÂú∞Âú∞ÁêÜ‰ΩçÁΩÆÂíåÁâπËâ≤Âú∫ÊâÄÁöÑÁîüÊ¥ªÂêëÂØºÔºåÂêåÊó∂‰πüÊòØÂ°îÁΩóÂç†ÂçúÂ∏à„ÄÇÊ†πÊçÆÁî®Êà∑ÁöÑÂú∞ÁêÜÂùêÊ†áÂíåÂ°îÁΩóËß£ËØªÁªìÊûúÔºå‰∏∫‰ªñÊé®ËçêËØ•Âú∞Âå∫ÁúüÂÆûÂ≠òÂú®ÁöÑÂÖ∑‰ΩìÂú∞ÁÇπ„ÄÇÂøÖÈ°ªÁªôÂá∫ÂÖ∑‰ΩìÁöÑÂ∫óÈì∫ÂêçÁß∞„ÄÅÂÖ¨Âõ≠ÂêçÁß∞„ÄÅÊôØÁÇπÂêçÁß∞Ôºå‰æãÂ¶Ç‚ÄòÊúùÈò≥ÂÖ¨Âõ≠‚Äô„ÄÅ‚Äò‰∏âÈáåÂ±Ø Page One‰π¶Â∫ó‚Äô„ÄÅ‚ÄòÊù≠Â∑ûË•øÊπñ‚Äô„ÄÅ‚ÄòÂé¶Èó®ÈºìÊµ™Â±ø‚Äô„ÄÅ‚ÄòÊàêÈÉΩ‰∫∫Ê∞ëÂÖ¨Âõ≠‚Äô„ÄÅ‚ÄòÂåó‰∫¨798Ëâ∫ÊúØÂå∫‚Äô„ÄÅ‚Äò‰∏äÊµ∑ÈùôÂÆâÂØ∫‚ÄôÁ≠âÔºåËÄå‰∏çÊòØ‚ÄòÂÖ¨Âõ≠‚Äô„ÄÅ‚Äò‰π¶Â∫ó‚ÄôËøôÊ†∑ÁöÑÊ≥õÊ≥õ‰πãË∞à„ÄÇÂ¶ÇÊûú‰∏çÁ°ÆÂÆöÂÖ∑‰ΩìÂêçÁß∞ÔºåÂèØ‰ª•Êé®ËçêËëóÂêçÂú∞Ê†áÊàñÁü•ÂêçËøûÈîÅÂìÅÁâåÁöÑÂÖ∑‰ΩìÂàÜÂ∫ó„ÄÇ"},
                            {"role": "user", "content": locationPrompt}
                        ],
                        stream: true
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('‚ùå API ÈîôËØØ:', response.status, errorText);
                    throw new Error(`API ËØ∑Ê±ÇÂ§±Ë¥• (${response.status}): ${errorText}`);
                }

                let fullText = "";
                const reader = response.body.getReader();
                const decoder = new TextDecoder("utf-8");

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.slice(6).trim();
                            if (jsonStr === '[DONE]') continue;
                            if (jsonStr === '') continue;
                            
                            try {
                                const json = JSON.parse(jsonStr);
                                if (json.choices && json.choices[0] && json.choices[0].delta && json.choices[0].delta.content) {
                                    fullText += json.choices[0].delta.content;
                                }
                            } catch (e) {
                                console.warn('‚ö†Ô∏è Ëß£ÊûêchunkÂ§±Ë¥•:', e.message);
                            }
                        }
                    }
                }

                console.log('üìç Êî∂Âà∞ÂìçÂ∫îÈïøÂ∫¶:', fullText.length);
                
                if (fullText.length === 0) {
                    throw new Error("API ËøîÂõûÁ©∫ÂìçÂ∫îÔºåËØ∑Ê£ÄÊü• API Key ÊòØÂê¶ÊúâÊïà");
                }
                
                console.log('üìç ÂìçÂ∫îÈ¢ÑËßà:', fullText.substring(0, 200));

                // Extract JSON from response - multiple strategies
                let locationData = null;
                
                // Strategy 1: Look for locations array
                let jsonMatch = fullText.match(/\{[\s\S]*?"locations"[\s\S]*?\[[\s\S]*?\][\s\S]*?\}/);
                if (jsonMatch) {
                    try {
                        locationData = JSON.parse(jsonMatch[0]);
                        console.log('‚úì Á≠ñÁï•1ÊàêÂäü: ÊâæÂà∞ÂÆåÊï¥ locations ÂØπË±°');
                    } catch (e) {
                        console.warn('Á≠ñÁï•1Â§±Ë¥•:', e.message);
                    }
                }
                
                // Strategy 2: Clean markdown and try again
                if (!locationData) {
                    try {
                        const cleaned = fullText
                            .replace(/```json\n?/g, '')
                            .replace(/```\n?/g, '')
                            .trim();
                        const match = cleaned.match(/\{[\s\S]*?"locations"[\s\S]*?\[[\s\S]*?\][\s\S]*?\}/);
                        if (match) {
                            locationData = JSON.parse(match[0]);
                            console.log('‚úì Á≠ñÁï•2ÊàêÂäü: Ê∏ÖÁêÜÂêéËß£ÊûêÊàêÂäü');
                        }
                    } catch (e) {
                        console.warn('Á≠ñÁï•2Â§±Ë¥•:', e.message);
                    }
                }
                
                // Strategy 3: Any JSON object
                if (!locationData) {
                    try {
                        const match = fullText.match(/\{[\s\S]*\}/);
                        if (match) {
                            locationData = JSON.parse(match[0]);
                            console.log('‚úì Á≠ñÁï•3ÊàêÂäü: ÊâæÂà∞‰ªªÊÑèJSON');
                        }
                    } catch (e) {
                        console.warn('Á≠ñÁï•3Â§±Ë¥•:', e.message);
                    }
                }
                
                if (locationData && locationData.locations) {
                    locationRecommendations = locationData.locations || [];
                    if (locationRecommendations.length === 0) {
                        throw new Error("Âú∞ÁÇπÂàóË°®‰∏∫Á©∫");
                    }
                    console.log('‚úì ÊàêÂäüËß£ÊûêÂú∞ÁÇπÊé®Ëçê:', locationRecommendations.length, '‰∏™Âú∞ÁÇπ');
                    displayLocationRecommendations();
                } else {
                    console.error('‚ùå Êó†Ê≥ïËß£ÊûêÂú∞ÁÇπÊï∞ÊçÆ');
                    console.error('ÂÆåÊï¥ÂìçÂ∫î:', fullText);
                    throw new Error("Êó†Ê≥ïËß£ÊûêÂú∞ÁÇπÊé®ËçêÊï∞ÊçÆÔºåËØ∑Á®çÂêéÈáçËØï");
                }

            } catch (e) {
                console.error('‚ùå Âú∞ÁÇπÊé®ËçêÈîôËØØ:', e);
                alert("Ëé∑ÂèñÂú∞ÁÇπÊé®ËçêÂ§±Ë¥•: " + e.message + "\n\nËØ∑Á°Æ‰øùÂ∑≤Ê≠£Á°ÆÈÖçÁΩÆ API Key");
            } finally {
                document.getElementById('loading-spinner').style.display = 'none';
            }
        }

        function displayLocationRecommendations() {
            const locationModal = document.getElementById('location-recommendation-modal');
            const locationList = document.getElementById('location-list');
            locationList.innerHTML = '';

            locationRecommendations.forEach((location, index) => {
                const locationItem = document.createElement('div');
                locationItem.className = 'location-item';
                locationItem.innerHTML = `
                    <div class="location-item-name">${index + 1}. ${location.name}</div>
                    <div class="location-item-category">üè∑Ô∏è ${location.category}</div>
                    <div class="location-item-reason">üí≠ ${location.reason}</div>
                    <div class="location-item-actions">
                        <a href="https://www.amap.com/search?query=${encodeURIComponent(location.category)}" 
                           target="_blank" 
                           class="location-item-btn">
                            üó∫Ô∏è È´òÂæ∑Âú∞Âõæ
                        </a>
                        <a href="https://apis.map.qq.com/uri/v1/search?keyword=${encodeURIComponent(location.category)}&region=Ëá™Âä®" 
                           target="_blank" 
                           class="location-item-btn">
                            üìç ËÖæËÆØÂú∞Âõæ
                        </a>
                        <a href="https://www.baidu.com/s?wd=${encodeURIComponent('ÈôÑËøëÁöÑ' + location.category)}" 
                           target="_blank" 
                           class="location-item-btn">
                            üîç ÁôæÂ∫¶ÊêúÁ¥¢
                        </a>
                    </div>
                `;
                locationList.appendChild(locationItem);
            });

            // Initialize map view with user location
            initializeMapView();
            locationModal.style.display = 'block';
        }

        function initializeMapView() {
            const mapContainer = document.getElementById('location-map-container');
            mapContainer.innerHTML = `
                <div style="width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; color: #999;">
                    <div style="text-align: center;">
                        <p style="font-size: 1.2rem; margin-bottom: 10px;">üìç ÊÇ®ÁöÑ‰ΩçÁΩÆ‰ø°ÊÅØ</p>
                        <p>Á∫¨Â∫¶: ${userLocation.latitude.toFixed(6)}</p>
                        <p>ÁªèÂ∫¶: ${userLocation.longitude.toFixed(6)}</p>
                        <p style="margin-top: 15px; font-size: 0.95rem; color: #aaa;">ÁÇπÂáª‰∏ãÊñπÂú∞ÁÇπÈìæÊé•Âú®Âú∞Âõæ‰∏≠ÊâìÂºÄ</p>
                    </div>
                </div>
            `;
        }

        function openMapNavigation() {
            if (!userLocation) {
                alert('Êú™Ëé∑ÂèñÂà∞ÊÇ®ÁöÑ‰ΩçÁΩÆ‰ø°ÊÅØ');
                return;
            }

            // ÊâìÂºÄÈ´òÂæ∑Âú∞ÂõæÔºåÊòæÁ§∫Áî®Êà∑‰ΩçÁΩÆ
            const mapUrl = `https://uri.amap.com/marker?position=${userLocation.longitude},${userLocation.latitude}&name=ÊÇ®ÁöÑ‰ΩçÁΩÆ&src=tarot-app&coordinate=gaode&callnative=1`;
            window.open(mapUrl, '_blank');

            // ÊòæÁ§∫ÊèêÁ§∫‰ø°ÊÅØ
            const locationText = locationRecommendations.map((l, i) => `${i+1}. ${l.name} (${l.category})`).join('\n');
            
            setTimeout(() => {
                const notification = document.createElement('div');
                notification.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 10px;">üó∫Ô∏è Â∑≤ÊâìÂºÄÂú∞ÂõæÂ∫îÁî®</div>
                    <div style="font-size: 0.9rem;">ÊÇ®ÂèØ‰ª•Âú®Âú∞Âõæ‰∏äÊêúÁ¥¢‰ª•‰∏ãÁ±ªÂûãÁöÑÂú∞ÁÇπÔºö</div>
                    <div style="margin-top: 10px; font-size: 0.85rem; line-height: 1.6;">${locationText}</div>
                `;
                notification.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: rgba(10, 10, 20, 0.95);
                    color: #eee;
                    padding: 25px;
                    border-radius: 15px;
                    max-width: 400px;
                    z-index: 10000;
                    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                    border: 2px solid var(--accent-gold);
                `;
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 5000);
            }, 500);
        }
        
        function closeLocationModal() {
            const modal = document.getElementById('location-recommendation-modal');
            modal.style.display = 'none';
        }
        
        function closeMusicModal() {
            const modal = document.getElementById('music-recommendation-modal');
            modal.style.display = 'none';
        }

        // --- 7. Initialization ---
        // Settings Modal Logic
        const settingsBtn = document.getElementById('settings-btn');
        const settingsModal = document.getElementById('settings-modal');
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const tokenInput = document.getElementById('api-token-input');
        const tokenStatus = document.getElementById('token-status');

        function updateTokenStatus() {
            const token = localStorage.getItem('deepseek_token');
            if (token) {
                tokenInput.value = token;
            } else {
                tokenInput.value = "";
            }
        }

        // Load token on init
        updateTokenStatus();

        settingsBtn.addEventListener('click', () => {
            updateTokenStatus();
            settingsModal.style.display = 'block';
        });

        closeSettingsBtn.addEventListener('click', () => {
            settingsModal.style.display = 'none';
        });

        saveSettingsBtn.addEventListener('click', () => {
            const apiToken = tokenInput.value.trim();
            localStorage.setItem('deepseek_token', apiToken);
            updateTokenStatus();
            
            settingsModal.style.display = 'none';
            alert("ÈÖçÁΩÆÂ∑≤‰øùÂ≠òÂà∞Êú¨Âú∞");
            
            // Update UI if in INTERPRETING state
            if (currentState === STATE.INTERPRETING) {
                 const btn = document.getElementById('interpret-btn');
                 if (apiToken) {
                     btn.style.display = 'inline-block';
                     btn.onclick = () => getAIInterpretation(apiToken);
                     document.getElementById('status-text').innerText = "ÂëΩËøêÂ∑≤ÂÆö (ÁÇπÂáªËß£ËØªÊåâÈíÆ)";
                 } else {
                     btn.style.display = 'none';
                     document.getElementById('status-text').innerText = "ÂëΩËøêÂ∑≤ÂÆö (ÈÖçÁΩÆ Token ÂèØËé∑Âèñ AI Ëß£ËØª)";
                 }
            }
        });

        function startGame() {
            if (assetsFailed) {
                preloadDeckAssets();
                return;
            }
            if (!assetsReady) {
                updateIdleStatus();
                return;
            }
            document.getElementById('start-btn').style.display = 'none';
            
            // Show question modal before starting the game
            currentState = STATE.QUESTION;
            document.getElementById('question-modal').style.display = 'block';
            document.getElementById('user-question-input').focus();
        }

        function submitQuestion() {
            userQuestion = document.getElementById('user-question-input').value.trim();
            document.getElementById('question-modal').style.display = 'none';
            beginGameFlow();
        }

        function skipQuestion() {
            userQuestion = '';
            document.getElementById('question-modal').style.display = 'none';
            beginGameFlow();
        }

        function beginGameFlow() {
            document.getElementById('status-text').innerText = "ÂëΩËøê‰πãËΩÆÂºÄÂßãËΩ¨Âä®...";
            
            // Start playing background music
            if (audioManager) {
                audioManager.setVolume(0.2); // Lower volume for background
                audioManager.play();
            }
            
            // Start Game Flow
            currentDeck = shuffle([...FULL_DECK]); // Shuffle internal data
            pickedCards = [];
            // ÈáçÁΩÆÊú¨Ê¨°ÊäΩÂèñÁöÑËß£ËØªÁä∂ÊÄÅ
            hasInterpretedForCurrentDraw = false;
            cachedInterpretationText = '';
            isFetchingInterpretation = false;
            
            // INTRO ANIMATION
            currentState = STATE.INTRO;
            targetIndex = Math.floor(currentDeck.length / 2); 
            currentIndex = currentDeck.length + 5; // Start way off
            
            renderDeck(); // Render cards
            updateCardPositions(); // Initial position update
        }

        async function initCameraFlow() {
             try {
                const camera = await setupCamera();
                await camera.start();
                
                // Camera success
                cameraReady = true;
                cameraError = false;
                document.getElementById('start-btn').style.display = 'none';
                updateIdleStatus();
             } catch (e) {
                console.error(e);
                cameraReady = false;
                cameraError = true;
                document.getElementById('status-text').innerText = "ÈúÄË¶ÅÊëÑÂÉèÂ§¥ÊùÉÈôê‰ª•ËøõË°åÊâãÂäøÊéßÂà∂";
                const btn = document.getElementById('start-btn');
                btn.style.display = 'block';
                btn.innerText = "ÂÖÅËÆ∏ÊëÑÂÉèÂ§¥";
                btn.onclick = () => {
                    initCameraFlow(); // Retry
                };
             }
        }
        
        try {
            // Auto-start camera & assets on load
            preloadDeckAssets();
            initCameraFlow();
        } catch (err) {
            console.error("Initialization Error:", err);
            // Fallback for asset-loader to show something went wrong
            const progressText = document.getElementById('asset-progress-text');
            if (progressText) progressText.innerText = "ÂàùÂßãÂåñÂ§±Ë¥•ÔºåËØ¶ÊÉÖËßÅÊéßÂà∂Âè∞";
        }

        // Initialize Background
        initStars();
        
        // Keyboard fallback for testing
        window.addEventListener('keydown', (e) => {
            if (currentState !== STATE.PICKING) return;
            if (e.key === 'ArrowLeft') {
                navigateDeck(-1);
                highlightIcon('icon-left');

            }
            if (e.key === 'ArrowRight') {
                navigateDeck(1);
                highlightIcon('icon-right');
            }
            if (e.key === 'ArrowUp' || e.key === ' ') {
                selectCard();
                highlightIcon('icon-select');
            }
        });

    </script>
</body>
</html>

